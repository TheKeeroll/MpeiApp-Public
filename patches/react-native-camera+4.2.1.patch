diff --git a/node_modules/react-native-camera/android/build.gradle b/node_modules/react-native-camera/android/build.gradle
index 4aed495..a00dc0d 100644
--- a/node_modules/react-native-camera/android/build.gradle
+++ b/node_modules/react-native-camera/android/build.gradle
@@ -10,12 +10,11 @@ buildscript {
     repositories {
       google()
       mavenCentral()
-      jcenter()
     }
 
     dependencies {
       //noinspection GradleDependency
-      classpath("com.android.tools.build:gradle:4.1.0")
+      classpath("com.android.tools.build:gradle:7.3.1")
     }
   }
 }
@@ -23,16 +22,16 @@ buildscript {
 apply plugin: 'com.android.library'
 
 android {
-  compileSdkVersion safeExtGet('compileSdkVersion', 29)
-  buildToolsVersion safeExtGet('buildToolsVersion', '29.0.2')
+  compileSdkVersion safeExtGet('compileSdkVersion', 35)
+  buildToolsVersion safeExtGet('buildToolsVersion', '35.0.0')
 
   defaultConfig {
-    multiDexEnabled true
-    minSdkVersion safeExtGet('minSdkVersion', 16)
-    targetSdkVersion safeExtGet('targetSdkVersion', 29)
+    // multiDexEnabled true
+    minSdkVersion safeExtGet('minSdkVersion', 23)
+    targetSdkVersion safeExtGet('targetSdkVersion', 35)
   }
 
-  flavorDimensions "react-native-camera"
+  /*flavorDimensions "react-native-camera"
 
   productFlavors {
     general {
@@ -41,11 +40,10 @@ android {
     mlkit {
       dimension "react-native-camera"
     }
-  }
+  }*/
 
-  lintOptions {
+  lint {
     abortOnError false
-    warning 'InvalidPackage'
   }
 
   packagingOptions {
@@ -56,7 +54,6 @@ android {
 
 repositories {
   google()
-  jcenter()
   mavenCentral()
   maven { url "https://jitpack.io" }
   maven {
@@ -74,8 +71,9 @@ dependencies {
   implementation "androidx.annotation:annotation:1.0.0"
   implementation "androidx.legacy:legacy-support-v4:1.0.0"
   implementation "com.google.android.gms:play-services-mlkit-text-recognition:16.3.0"
-  generalImplementation "com.google.android.gms:play-services-mlkit-barcode-scanning:16.2.0"
-  generalImplementation "com.google.android.gms:play-services-mlkit-face-detection:16.2.0"
-  mlkitImplementation "com.google.mlkit:barcode-scanning:16.2.0"
-  mlkitImplementation "com.google.mlkit:face-detection:16.1.2"
+  implementation "com.google.android.gms:play-services-mlkit-barcode-scanning:16.2.0"
+  implementation "com.google.android.gms:play-services-mlkit-face-detection:16.2.0"
+  implementation project(':react-native-camera-tflite')
+  implementation 'com.google.android.gms:play-services-vision:15.0.2'
+
 }
diff --git a/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/AspectRatio.java b/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/AspectRatio.java
index e15398d..9fb7b33 100644
--- a/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/AspectRatio.java
+++ b/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/AspectRatio.java
@@ -14,16 +14,16 @@
  * limitations under the License.
  */
 
-package com.google.android.cameraview;
+/*package com.google.android.cameraview;
 
 import android.os.Parcel;
 import android.os.Parcelable;
 import androidx.annotation.NonNull;
 import androidx.collection.SparseArrayCompat;
 
-/**
+*//**
  * Immutable class for describing proportional relationship between width and height.
- */
+ *//*
 public class AspectRatio implements Comparable<AspectRatio>, Parcelable {
 
     private final static SparseArrayCompat<SparseArrayCompat<AspectRatio>> sCache
@@ -32,14 +32,14 @@ public class AspectRatio implements Comparable<AspectRatio>, Parcelable {
     private final int mX;
     private final int mY;
 
-    /**
+    *//**
      * Returns an instance of {@link AspectRatio} specified by {@code x} and {@code y} values.
      * The values {@code x} and {@code} will be reduced by their greatest common divider.
      *
      * @param x The width
      * @param y The height
      * @return An instance of {@link AspectRatio}
-     */
+     *//*
     public static AspectRatio of(int x, int y) {
         int gcd = gcd(x, y);
         x /= gcd;
@@ -61,13 +61,13 @@ public class AspectRatio implements Comparable<AspectRatio>, Parcelable {
         }
     }
 
-    /**
+    *//**
      * Parse an {@link AspectRatio} from a {@link String} formatted like "4:3".
      *
      * @param s The string representation of the aspect ratio
      * @return The aspect ratio
      * @throws IllegalArgumentException when the format is incorrect.
-     */
+     *//*
     public static AspectRatio parse(String s) {
         int position = s.indexOf(':');
         if (position == -1) {
@@ -142,9 +142,9 @@ public class AspectRatio implements Comparable<AspectRatio>, Parcelable {
         return -1;
     }
 
-    /**
+    *//**
      * @return The inverse of this {@link AspectRatio}.
-     */
+     *//*
     public AspectRatio inverse() {
         //noinspection SuspiciousNameCombination
         return AspectRatio.of(mY, mX);
@@ -186,4 +186,4 @@ public class AspectRatio implements Comparable<AspectRatio>, Parcelable {
         }
     };
 
-}
+}*/
diff --git a/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/Camera1.java b/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/Camera1.java
index f44f551..9730483 100644
--- a/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/Camera1.java
+++ b/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/Camera1.java
@@ -12,7 +12,8 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */
+ *//*
+
 
 package com.google.android.cameraview;
 
@@ -994,9 +995,11 @@ class Camera1 extends CameraViewImpl implements MediaRecorder.OnInfoListener,
         return new Size(cameraSize.width, cameraSize.height);
     }
 
-    /**
+    */
+/**
      * This rewrites {@link #mCameraId} and {@link #mCameraInfo}.
-     */
+     *//*
+
     private void chooseCamera() {
         if(_mCameraId == null || _mCameraId.isEmpty()){
 
@@ -1357,7 +1360,8 @@ class Camera1 extends CameraViewImpl implements MediaRecorder.OnInfoListener,
         return new Rect(left - 1000, top - 1000, right - 1000, bottom - 1000);
     }
 
-    /**
+    */
+/**
      * Calculate display orientation
      * https://developer.android.com/reference/android/hardware/Camera.html#setDisplayOrientation(int)
      *
@@ -1367,7 +1371,8 @@ class Camera1 extends CameraViewImpl implements MediaRecorder.OnInfoListener,
      *
      * @param screenOrientationDegrees Screen orientation in degrees
      * @return Number of degrees required to rotate preview
-     */
+     *//*
+
     private int calcDisplayOrientation(int screenOrientationDegrees) {
         if (mCameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
             return (360 - (mCameraInfo.orientation + screenOrientationDegrees) % 360) % 360;
@@ -1376,7 +1381,8 @@ class Camera1 extends CameraViewImpl implements MediaRecorder.OnInfoListener,
         }
     }
 
-    /**
+    */
+/**
      * Calculate camera rotation
      *
      * This calculation is applied to the output JPEG either via Exif Orientation tag
@@ -1386,7 +1392,8 @@ class Camera1 extends CameraViewImpl implements MediaRecorder.OnInfoListener,
      *
      * @param screenOrientationDegrees Screen orientation in degrees
      * @return Number of degrees to rotate image in order for it to view correctly.
-     */
+     *//*
+
     private int calcCameraRotation(int screenOrientationDegrees) {
        if (mCameraInfo.facing == Camera.CameraInfo.CAMERA_FACING_BACK) {
            return (mCameraInfo.orientation + screenOrientationDegrees) % 360;
@@ -1396,20 +1403,24 @@ class Camera1 extends CameraViewImpl implements MediaRecorder.OnInfoListener,
        return (mCameraInfo.orientation + screenOrientationDegrees + landscapeFlip) % 360;
     }
 
-    /**
+    */
+/**
      * Test if the supplied orientation is in landscape.
      *
      * @param orientationDegrees Orientation in degrees (0,90,180,270)
      * @return True if in landscape, false if portrait
-     */
+     *//*
+
     private boolean isLandscape(int orientationDegrees) {
         return (orientationDegrees == Constants.LANDSCAPE_90 ||
                 orientationDegrees == Constants.LANDSCAPE_270);
     }
 
-    /**
+    */
+/**
      * @return {@code true} if {@link #mCameraParameters} was modified.
-     */
+     *//*
+
     private boolean setAutoFocusInternal(boolean autoFocus) {
         mAutoFocus = autoFocus;
         if (isCameraOpened()) {
@@ -1431,9 +1442,11 @@ class Camera1 extends CameraViewImpl implements MediaRecorder.OnInfoListener,
         }
     }
 
-    /**
+    */
+/**
      * @return {@code true} if {@link #mCameraParameters} was modified.
-     */
+     *//*
+
     private boolean setFlashInternal(int flash) {
         if (isCameraOpened()) {
             List<String> modes = mCameraParameters.getSupportedFlashModes();
@@ -1478,9 +1491,11 @@ class Camera1 extends CameraViewImpl implements MediaRecorder.OnInfoListener,
     }
 
 
-    /**
+    */
+/**
      * @return {@code true} if {@link #mCameraParameters} was modified.
-     */
+     *//*
+
     private boolean setZoomInternal(float zoom) {
         if (isCameraOpened() && mCameraParameters.isZoomSupported()) {
             int maxZoom = mCameraParameters.getMaxZoom();
@@ -1494,9 +1509,11 @@ class Camera1 extends CameraViewImpl implements MediaRecorder.OnInfoListener,
         }
     }
 
-    /**
+    */
+/**
      * @return {@code true} if {@link #mCameraParameters} was modified.
-     */
+     *//*
+
     private boolean setWhiteBalanceInternal(int whiteBalance) {
         mWhiteBalance = whiteBalance;
         if (isCameraOpened()) {
@@ -1715,3 +1732,4 @@ class Camera1 extends CameraViewImpl implements MediaRecorder.OnInfoListener,
         stopRecording();
     }
 }
+*/
diff --git a/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/Camera2.java b/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/Camera2.java
index 8fd598a..3c71114 100644
--- a/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/Camera2.java
+++ b/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/Camera2.java
@@ -12,11 +12,11 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
- */
+ *//*
+
 
 package com.google.android.cameraview;
 
-import android.annotation.TargetApi;
 import android.content.Context;
 import android.graphics.ImageFormat;
 import android.graphics.Rect;
@@ -64,7 +64,6 @@ import org.reactnative.camera.utils.ObjectUtils;
 
 
 @SuppressWarnings("MissingPermission")
-@TargetApi(21)
 class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, MediaRecorder.OnErrorListener {
 
     private static final String TAG = "Camera2";
@@ -76,14 +75,18 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         INTERNAL_FACINGS.put(Constants.FACING_FRONT, CameraCharacteristics.LENS_FACING_FRONT);
     }
 
-    /**
+    */
+/**
      * Max preview width that is guaranteed by Camera2 API
-     */
+     *//*
+
     private static final int MAX_PREVIEW_WIDTH = 1920;
 
-    /**
+    */
+/**
      * Max preview height that is guaranteed by Camera2 API
-     */
+     *//*
+
     private static final int MAX_PREVIEW_HEIGHT = 1080;
 
     private static final int FOCUS_AREA_SIZE_DEFAULT = 300;
@@ -792,11 +795,13 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         }
     }
 
-    /**
+    */
+/**
      * <p>Chooses a camera ID by the specified camera facing ({@link #mFacing}).</p>
      * <p>This rewrites {@link #mCameraId}, {@link #mCameraCharacteristics}, and optionally
      * {@link #mFacing}.</p>
-     */
+     *//*
+
     private boolean chooseCameraIdByFacing() {
         if(_mCameraId == null || _mCameraId.isEmpty()){
             try {
@@ -874,11 +879,13 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         }
     }
 
-    /**
+    */
+/**
      * <p>Collects some information from {@link #mCameraCharacteristics}.</p>
      * <p>This rewrites {@link #mPreviewSizes}, {@link #mPictureSizes},
      * {@link #mCameraOrientation}, and optionally, {@link #mAspectRatio}.</p>
-     */
+     *//*
+
     private void collectCameraInfo() {
         StreamConfigurationMap map = mCameraCharacteristics.get(
                 CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
@@ -936,10 +943,12 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         mScanImageReader.setOnImageAvailableListener(mOnImageAvailableListener, null);
     }
 
-    /**
+    */
+/**
      * <p>Starts opening a camera device.</p>
      * <p>The result will be processed in {@link #mCameraDeviceCallback}.</p>
-     */
+     *//*
+
     private void startOpeningCamera() {
         try {
             mCameraManager.openCamera(mCameraId, mCameraDeviceCallback, null);
@@ -948,11 +957,13 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         }
     }
 
-    /**
+    */
+/**
      * <p>Starts a capture session for camera preview.</p>
      * <p>This rewrites {@link #mPreviewRequestBuilder}.</p>
      * <p>The result will be continuously processed in {@link #mSessionCallback}.</p>
-     */
+     *//*
+
     void startCaptureSession() {
         if (!isCameraOpened() || !mPreview.isReady() || mStillImageReader == null || mScanImageReader == null) {
             return;
@@ -1024,11 +1035,13 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         return new Size(mPreview.getWidth(), mPreview.getHeight());
     }
 
-    /**
+    */
+/**
      * Chooses the optimal preview size based on {@link #mPreviewSizes} and the surface size.
      *
      * @return The picked size for camera preview.
-     */
+     *//*
+
     private Size chooseOptimalSize() {
         int surfaceLonger, surfaceShorter;
         final int surfaceWidth = mPreview.getWidth();
@@ -1052,9 +1065,11 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         return candidates.last();
     }
 
-    /**
+    */
+/**
      * Updates the internal state of auto-focus to {@link #mAutoFocus}.
-     */
+     *//*
+
     void updateAutoFocus() {
         if (mAutoFocus) {
             int[] modes = mCameraCharacteristics.get(
@@ -1075,9 +1090,11 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         }
     }
 
-    /**
+    */
+/**
      * Updates the internal state of flash to {@link #mFlash}.
-     */
+     *//*
+
     void updateFlash() {
         switch (mFlash) {
             case Constants.FLASH_OFF:
@@ -1113,9 +1130,11 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         }
     }
 
-    /**
+    */
+/**
      * Updates the internal state of focus depth to {@link #mFocusDepth}.
-     */
+     *//*
+
     void updateFocusDepth() {
         if (mAutoFocus) {
           return;
@@ -1128,9 +1147,11 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         mPreviewRequestBuilder.set(CaptureRequest.LENS_FOCUS_DISTANCE, value);
     }
 
-    /**
+    */
+/**
      * Updates the internal state of zoom to {@link #mZoom}.
-     */
+     *//*
+
     void updateZoom() {
         float maxZoom = mCameraCharacteristics.get(CameraCharacteristics.SCALER_AVAILABLE_MAX_DIGITAL_ZOOM);
         float scaledZoom = mZoom * (maxZoom - 1.0f) + 1.0f;
@@ -1160,9 +1181,11 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         }
     }
 
-    /**
+    */
+/**
      * Updates the internal state of white balance to {@link #mWhiteBalance}.
-     */
+     *//*
+
     void updateWhiteBalance() {
         switch (mWhiteBalance) {
             case Constants.WB_AUTO:
@@ -1192,9 +1215,11 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         }
     }
 
-    /**
+    */
+/**
      * Locks the focus as the first step for a still image capture.
-     */
+     *//*
+
     private void lockFocus() {
         mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,
                 CaptureRequest.CONTROL_AF_TRIGGER_START);
@@ -1207,9 +1232,11 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
     }
 
 
-    /**
+    */
+/**
      * Auto focus on input coordinates
-     */
+     *//*
+
 
     // Much credit - https://gist.github.com/royshil/8c760c2485257c85a11cafd958548482
     void setFocusArea(float x, float y) {
@@ -1289,9 +1316,11 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         return focusAreaTouch;
     }
 
-    /**
+    */
+/**
      * Captures a still picture.
-     */
+     *//*
+
     void captureStillPicture() {
         try {
             CaptureRequest.Builder captureRequestBuilder = mCamera.createCaptureRequest(
@@ -1373,12 +1402,14 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         }
     }
 
-    /**
+    */
+/**
      * Test if the supplied orientation is in landscape.
      *
      * @param orientationDegrees Orientation in degrees (0,90,180,270)
      * @return True if in landscape, false if portrait
-     */
+     *//*
+
     private boolean isLandscape(int orientationDegrees) {
         return (orientationDegrees == Constants.LANDSCAPE_90 ||
                 orientationDegrees == Constants.LANDSCAPE_270);
@@ -1469,10 +1500,12 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         }
     }
 
-    /**
+    */
+/**
      * Unlocks the auto-focus and restart camera preview. This is supposed to be called after
      * capturing a still picture.
-     */
+     *//*
+
     void unlockFocus() {
         mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,
                 CaptureRequest.CONTROL_AF_TRIGGER_CANCEL);
@@ -1495,9 +1528,11 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         }
     }
 
-    /**
+    */
+/**
      * Called when an something occurs while recording.
-     */
+     *//*
+
     public void onInfo(MediaRecorder mr, int what, int extra) {
         if ( what == MediaRecorder.MEDIA_RECORDER_INFO_MAX_DURATION_REACHED ||
             what == MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED) {
@@ -1505,16 +1540,20 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
         }
     }
 
-    /**
+    */
+/**
      * Called when an error occurs while recording.
-     */
+     *//*
+
     public void onError(MediaRecorder mr, int what, int extra) {
         stopRecording();
     }
 
-    /**
+    */
+/**
      * A {@link CameraCaptureSession.CaptureCallback} for capturing a still picture.
-     */
+     *//*
+
     private static abstract class PictureCaptureCallback
             extends CameraCaptureSession.CaptureCallback {
 
@@ -1591,16 +1630,21 @@ class Camera2 extends CameraViewImpl implements MediaRecorder.OnInfoListener, Me
             }
         }
 
-        /**
+        */
+/**
          * Called when it is ready to take a still picture.
-         */
+         *//*
+
         public abstract void onReady();
 
-        /**
+        */
+/**
          * Called when it is necessary to run the precapture sequence.
-         */
+         *//*
+
         public abstract void onPrecaptureRequired();
 
     }
 
 }
+*/
diff --git a/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/Camera2Api23.java b/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/Camera2Api23.java
index 396ea8b..acfb4fa 100644
--- a/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/Camera2Api23.java
+++ b/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/Camera2Api23.java
@@ -23,11 +23,11 @@ import android.hardware.camera2.params.StreamConfigurationMap;
 import android.os.Handler;
 
 
-@TargetApi(23)
 class Camera2Api23 extends Camera2 {
 
     Camera2Api23(Callback callback, PreviewImpl preview, Context context, Handler bgHandler) {
-        super(callback, preview, context, bgHandler);
+//        super(callback, preview, context, bgHandler);
+        super(callback, preview, context);
     }
 
     @Override
diff --git a/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/CameraView.java b/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/CameraView.java
index 11f96f9..2b431fe 100644
--- a/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/CameraView.java
+++ b/node_modules/react-native-camera/android/src/main/java/com/google/android/cameraview/CameraView.java
@@ -126,10 +126,10 @@ public class CameraView extends FrameLayout {
         // Internal setup
         final PreviewImpl preview = createPreviewImpl(context);
         mCallbacks = new CallbackBridge();
-        if (fallbackToOldApi || Build.VERSION.SDK_INT < 21 || Camera2.isLegacy(context)) {
-            mImpl = new Camera1(mCallbacks, preview, mBgHandler);
-        } else if (Build.VERSION.SDK_INT < 23) {
-            mImpl = new Camera2(mCallbacks, preview, context, mBgHandler);
+//        if (fallbackToOldApi || Camera2.isLegacy(context)) {
+        if (fallbackToOldApi) {
+//            mImpl = new Camera1(mCallbacks, preview, mBgHandler);
+            mImpl = new Camera1(mCallbacks, preview);
         } else {
             mImpl = new Camera2Api23(mCallbacks, preview, context, mBgHandler);
         }
@@ -146,12 +146,7 @@ public class CameraView extends FrameLayout {
 
     public void cleanup(){
         if(mBgThread != null){
-            if(Build.VERSION.SDK_INT < 18){
-                mBgThread.quit();
-            }
-            else{
-                mBgThread.quitSafely();
-            }
+            mBgThread.quitSafely();
 
             mBgThread = null;
         }
@@ -160,11 +155,7 @@ public class CameraView extends FrameLayout {
     @NonNull
     private PreviewImpl createPreviewImpl(Context context) {
         PreviewImpl preview;
-        if (Build.VERSION.SDK_INT < 14) {
-            preview = new SurfaceViewPreview(context, this);
-        } else {
-            preview = new TextureViewPreview(context, this);
-        }
+        preview = new TextureViewPreview(context, this);
         return preview;
     }
 
@@ -287,22 +278,16 @@ public class CameraView extends FrameLayout {
     }
 
     public void setUsingCamera2Api(boolean useCamera2) {
-        if (Build.VERSION.SDK_INT < 21) {
-            return;
-        }
 
         boolean wasOpened = isCameraOpened();
         Parcelable state = onSaveInstanceState();
 
-        if (useCamera2 && !Camera2.isLegacy(mContext)) {
+//        if (useCamera2 && !Camera2.isLegacy(mContext)) {
+        if (useCamera2) {
             if (wasOpened) {
                 stop();
             }
-            if (Build.VERSION.SDK_INT < 23) {
-                mImpl = new Camera2(mCallbacks, mImpl.mPreview, mContext, mBgHandler);
-            } else {
-                mImpl = new Camera2Api23(mCallbacks, mImpl.mPreview, mContext, mBgHandler);
-            }
+            mImpl = new Camera2Api23(mCallbacks, mImpl.mPreview, mContext, mBgHandler);
 
             onRestoreInstanceState(state);
         } else {
@@ -313,7 +298,7 @@ public class CameraView extends FrameLayout {
             if (wasOpened) {
                 stop();
             }
-            mImpl = new Camera1(mCallbacks, mImpl.mPreview, mBgHandler);
+            mImpl = new Camera1(mCallbacks, mImpl.mPreview);
         }
         if(wasOpened){
             start();
@@ -322,7 +307,7 @@ public class CameraView extends FrameLayout {
 
     /**
      * Open a camera device and start showing camera preview. This is typically called from
-     * {@link Activity#onResume()}.
+     * {onResume()}.
      */
     public void start() {
         mImpl.start();
@@ -343,7 +328,7 @@ public class CameraView extends FrameLayout {
 
     /**
      * Stop camera preview and close the device. This is typically called from
-     * {@link Activity#onPause()}.
+     * {onPause()}.
      */
     public void stop() {
         mImpl.stop();
@@ -620,7 +605,7 @@ public class CameraView extends FrameLayout {
 
     /**
      * Take a picture. The result will be returned to
-     * {@link Callback#onPictureTaken(CameraView, byte[], int)}.
+     * {onPictureTaken(CameraView, byte[], int)}.
      */
     public void takePicture(ReadableMap options) {
         mImpl.takePicture(options);
@@ -878,7 +863,7 @@ public class CameraView extends FrameLayout {
          * Called when a video recording ends, but before video is saved/processed.
          *
          * @param cameraView The associated {@link CameraView}.
-         * @param path       Path to recoredd video file.
+         * path       Path to recoredd video file.
          */
         public void onRecordingEnd(CameraView cameraView){}
 
diff --git a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/MutableImage.java b/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/MutableImage.java
deleted file mode 100644
index e5d8141..0000000
--- a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/MutableImage.java
+++ /dev/null
@@ -1,327 +0,0 @@
-package com.lwansbrough.RCTCamera;
-
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.Matrix;
-import androidx.exifinterface.media.ExifInterface;
-import android.util.Base64;
-import android.util.Log;
-
-import com.drew.imaging.ImageMetadataReader;
-import com.drew.imaging.ImageProcessingException;
-import com.drew.metadata.Directory;
-import com.drew.metadata.Metadata;
-import com.drew.metadata.MetadataException;
-import com.drew.metadata.Tag;
-import com.drew.metadata.exif.ExifIFD0Directory;
-import com.drew.metadata.exif.ExifSubIFDDirectory;
-import com.facebook.react.bridge.ReadableMap;
-
-import java.io.BufferedInputStream;
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-
-public class MutableImage {
-    private static final String TAG = "RNCamera";
-
-    private final byte[] originalImageData;
-    private Bitmap currentRepresentation;
-    private Metadata originalImageMetaData;
-    private boolean hasBeenReoriented = false;
-
-    public MutableImage(byte[] originalImageData) {
-        this.originalImageData = originalImageData;
-        this.currentRepresentation = toBitmap(originalImageData);
-    }
-
-    public int getWidth() {
-        return this.currentRepresentation.getWidth();
-    }
-
-    public int getHeight() {
-        return this.currentRepresentation.getHeight();
-    }
-
-    public void mirrorImage() throws ImageMutationFailedException {
-        Matrix m = new Matrix();
-
-        m.preScale(-1, 1);
-
-        Bitmap bitmap = Bitmap.createBitmap(
-                currentRepresentation,
-                0,
-                0,
-                getWidth(),
-                getHeight(),
-                m,
-                false
-        );
-
-        if (bitmap == null)
-            throw new ImageMutationFailedException("failed to mirror");
-
-        this.currentRepresentation = bitmap;
-    }
-
-    public void fixOrientation() throws ImageMutationFailedException {
-        try {
-            Metadata metadata = originalImageMetaData();
-
-            ExifIFD0Directory exifIFD0Directory = metadata.getFirstDirectoryOfType(ExifIFD0Directory.class);
-            if (exifIFD0Directory == null) {
-                return;
-            } else if (exifIFD0Directory.containsTag(ExifIFD0Directory.TAG_ORIENTATION)) {
-                int exifOrientation = exifIFD0Directory.getInt(ExifIFD0Directory.TAG_ORIENTATION);
-                if(exifOrientation != 1) {
-                    rotate(exifOrientation);
-                    exifIFD0Directory.setInt(ExifIFD0Directory.TAG_ORIENTATION, 1);
-                }
-            }
-        } catch (ImageProcessingException | IOException | MetadataException e) {
-            throw new ImageMutationFailedException("failed to fix orientation", e);
-        }
-    }
-
-    public void cropToPreview(double previewRatio) throws IllegalArgumentException {
-        int pictureWidth = getWidth(), pictureHeight = getHeight();
-        int targetPictureWidth, targetPictureHeight;
-
-        if (previewRatio * pictureHeight > pictureWidth) {
-            targetPictureWidth = pictureWidth;
-            targetPictureHeight = (int) (pictureWidth / previewRatio);
-        } else {
-            targetPictureHeight = pictureHeight;
-            targetPictureWidth = (int) (pictureHeight * previewRatio);
-        }
-        this.currentRepresentation = Bitmap.createBitmap(
-                this.currentRepresentation,
-                (pictureWidth - targetPictureWidth) / 2,
-                (pictureHeight - targetPictureHeight) / 2,
-                targetPictureWidth,
-                targetPictureHeight);
-    }
-
-    //see http://www.impulseadventure.com/photo/exif-orientation.html
-    private void rotate(int exifOrientation) throws ImageMutationFailedException {
-        final Matrix bitmapMatrix = new Matrix();
-        switch (exifOrientation) {
-            case 1:
-                return;//no rotation required
-            case 2:
-                bitmapMatrix.postScale(-1, 1);
-                break;
-            case 3:
-                bitmapMatrix.postRotate(180);
-                break;
-            case 4:
-                bitmapMatrix.postRotate(180);
-                bitmapMatrix.postScale(-1, 1);
-                break;
-            case 5:
-                bitmapMatrix.postRotate(90);
-                bitmapMatrix.postScale(-1, 1);
-                break;
-            case 6:
-                bitmapMatrix.postRotate(90);
-                break;
-            case 7:
-                bitmapMatrix.postRotate(270);
-                bitmapMatrix.postScale(-1, 1);
-                break;
-            case 8:
-                bitmapMatrix.postRotate(270);
-                break;
-            default:
-                break;
-        }
-
-        Bitmap transformedBitmap = Bitmap.createBitmap(
-                currentRepresentation,
-                0,
-                0,
-                getWidth(),
-                getHeight(),
-                bitmapMatrix,
-                false
-        );
-
-        if (transformedBitmap == null)
-            throw new ImageMutationFailedException("failed to rotate");
-
-        this.currentRepresentation = transformedBitmap;
-        this.hasBeenReoriented = true;
-    }
-
-    private static Bitmap toBitmap(byte[] data) {
-        try {
-            ByteArrayInputStream inputStream = new ByteArrayInputStream(data);
-            Bitmap photo = BitmapFactory.decodeStream(inputStream);
-            inputStream.close();
-            return photo;
-        } catch (IOException e) {
-            throw new IllegalStateException("Will not happen", e);
-        }
-    }
-
-    public String toBase64(int jpegQualityPercent) {
-        return Base64.encodeToString(toJpeg(currentRepresentation, jpegQualityPercent), Base64.NO_WRAP);
-    }
-
-    public void writeDataToFile(File file, ReadableMap options, int jpegQualityPercent) throws IOException {
-        FileOutputStream fos = new FileOutputStream(file);
-        fos.write(toJpeg(currentRepresentation, jpegQualityPercent));
-        fos.close();
-
-        try {
-            ExifInterface exif = new ExifInterface(file.getAbsolutePath());
-
-            // copy original exif data to the output exif...
-            for (Directory directory : originalImageMetaData().getDirectories()) {
-                for (Tag tag : directory.getTags()) {
-                    int tagType = tag.getTagType();
-                    Object object = directory.getObject(tagType);
-                    exif.setAttribute(tag.getTagName(), object.toString());
-                }
-            }
-
-            // Add missing exif data from a sub directory
-            ExifSubIFDDirectory directory = originalImageMetaData()
-               .getFirstDirectoryOfType(ExifSubIFDDirectory.class);
-            for (Tag tag : directory.getTags()) {
-                int tagType = tag.getTagType();
-                // As some of exif data does not follow naming of the ExifInterface the names need
-                // to be transformed into Upper camel case format.
-                String tagName = tag.getTagName().replaceAll(" ", "");
-                Object object = directory.getObject(tagType);
-                if (tagName.equals(ExifInterface.TAG_EXPOSURE_TIME)) {
-                    exif.setAttribute(tagName, convertExposureTimeToDoubleFormat(object.toString()));
-                } else {
-                    exif.setAttribute(tagName, object.toString());
-                }
-            }
-
-            writeLocationExifData(options, exif);
-
-            if(hasBeenReoriented)
-                rewriteOrientation(exif);
-
-            exif.saveAttributes();
-        } catch (ImageProcessingException  | IOException e) {
-            Log.e(TAG, "failed to save exif data", e);
-        }
-    }
-
-    // Reformats exposure time value to match ExifInterface format. Example 1/11 -> 0.0909
-    // Even the value is formatted as double it is returned as a String because exif.setAttribute requires it.
-    private String convertExposureTimeToDoubleFormat(String exposureTime) {
-        if(!exposureTime.contains("/"))
-          return "";
-
-        String exposureFractions[]= exposureTime.split("/");
-        double divider = Double.parseDouble(exposureFractions[1]);
-        double exposureTimeAsDouble = 1.0f / divider;
-        return Double.toString(exposureTimeAsDouble);
-    }
-
-    private void rewriteOrientation(ExifInterface exif) {
-        exif.setAttribute(ExifInterface.TAG_ORIENTATION, String.valueOf(ExifInterface.ORIENTATION_NORMAL));
-    }
-
-    private void writeLocationExifData(ReadableMap options, ExifInterface exif) {
-        if(!options.hasKey("metadata"))
-            return;
-
-        ReadableMap metadata = options.getMap("metadata");
-        if (!metadata.hasKey("location"))
-            return;
-
-        ReadableMap location = metadata.getMap("location");
-        if(!location.hasKey("coords"))
-            return;
-
-        try {
-            ReadableMap coords = location.getMap("coords");
-            double latitude = coords.getDouble("latitude");
-            double longitude = coords.getDouble("longitude");
-
-            GPS.writeExifData(latitude, longitude, exif);
-        } catch (IOException e) {
-            Log.e(TAG, "Couldn't write location data", e);
-        }
-    }
-
-    private Metadata originalImageMetaData() throws ImageProcessingException, IOException {
-        if(this.originalImageMetaData == null) {//this is expensive, don't do it more than once
-            originalImageMetaData = ImageMetadataReader.readMetadata(
-                    new BufferedInputStream(new ByteArrayInputStream(originalImageData)),
-                    originalImageData.length
-            );
-        }
-        return originalImageMetaData;
-    }
-
-    private static byte[] toJpeg(Bitmap bitmap, int quality) throws OutOfMemoryError {
-        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
-        bitmap.compress(Bitmap.CompressFormat.JPEG, quality, outputStream);
-
-        try {
-            return outputStream.toByteArray();
-        } finally {
-            try {
-                outputStream.close();
-            } catch (IOException e) {
-                Log.e(TAG, "problem compressing jpeg", e);
-            }
-        }
-    }
-
-    public static class ImageMutationFailedException extends Exception {
-        public ImageMutationFailedException(String detailMessage, Throwable throwable) {
-            super(detailMessage, throwable);
-        }
-
-        public ImageMutationFailedException(String detailMessage) {
-            super(detailMessage);
-        }
-    }
-
-    private static class GPS {
-        public static void writeExifData(double latitude, double longitude, ExifInterface exif) throws IOException {
-            exif.setAttribute(ExifInterface.TAG_GPS_LATITUDE, toDegreeMinuteSeconds(latitude));
-            exif.setAttribute(ExifInterface.TAG_GPS_LATITUDE_REF, latitudeRef(latitude));
-            exif.setAttribute(ExifInterface.TAG_GPS_LONGITUDE, toDegreeMinuteSeconds(longitude));
-            exif.setAttribute(ExifInterface.TAG_GPS_LONGITUDE_REF, longitudeRef(longitude));
-        }
-
-        private static String latitudeRef(double latitude) {
-            return latitude < 0.0d ? "S" : "N";
-        }
-
-        private static String longitudeRef(double longitude) {
-            return longitude < 0.0d ? "W" : "E";
-        }
-
-        private static String toDegreeMinuteSeconds(double latitude) {
-            latitude = Math.abs(latitude);
-            int degree = (int) latitude;
-            latitude *= 60;
-            latitude -= (degree * 60.0d);
-            int minute = (int) latitude;
-            latitude *= 60;
-            latitude -= (minute * 60.0d);
-            int second = (int) (latitude * 1000.0d);
-
-            StringBuffer sb = new StringBuffer();
-            sb.append(degree);
-            sb.append("/1,");
-            sb.append(minute);
-            sb.append("/1,");
-            sb.append(second);
-            sb.append("/1000,");
-            return sb.toString();
-        }
-    }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCamera.java b/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCamera.java
deleted file mode 100644
index 96ff741..0000000
--- a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCamera.java
+++ /dev/null
@@ -1,536 +0,0 @@
-/**
- * Created by Fabrice Armisen (farmisen@gmail.com) on 1/4/16.
- */
-
-package com.lwansbrough.RCTCamera;
-
-import android.graphics.drawable.GradientDrawable;
-import android.hardware.Camera;
-import android.media.CamcorderProfile;
-import android.util.Log;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.lang.Math;
-
-public class RCTCamera {
-    private static RCTCamera ourInstance;
-    private final HashMap<Integer, CameraInfoWrapper> _cameraInfos;
-    private final HashMap<Integer, Integer> _cameraTypeToIndex;
-    private final Map<Number, Camera> _cameras;
-    private static final Resolution RESOLUTION_480P = new Resolution(853, 480); // 480p shoots for a 16:9 HD aspect ratio, but can otherwise fall back/down to any other supported camera sizes, such as 800x480 or 720x480, if (any) present. See getSupportedPictureSizes/getSupportedVideoSizes below.
-    private static final Resolution RESOLUTION_720P = new Resolution(1280, 720);
-    private static final Resolution RESOLUTION_1080P = new Resolution(1920, 1080);
-    private boolean _barcodeScannerEnabled = false;
-    private List<String> _barCodeTypes = null;
-    private int _orientation = -1;
-    private int _actualDeviceOrientation = 0;
-    private int _adjustedDeviceOrientation = 0;
-
-    public static RCTCamera getInstance() {
-        return ourInstance;
-    }
-    public static void createInstance(int deviceOrientation) {
-        ourInstance = new RCTCamera(deviceOrientation);
-    }
-
-
-    public synchronized Camera acquireCameraInstance(int type) {
-        if (null == _cameras.get(type) && null != _cameraTypeToIndex.get(type)) {
-            try {
-                Camera camera = Camera.open(_cameraTypeToIndex.get(type));
-                _cameras.put(type, camera);
-                adjustPreviewLayout(type);
-            } catch (Exception e) {
-                Log.e("RCTCamera", "acquireCameraInstance failed", e);
-            }
-        }
-        return _cameras.get(type);
-    }
-
-    public void releaseCameraInstance(int type) {
-        // Release seems async and creates race conditions. Remove from map first before releasing.
-        Camera releasingCamera = _cameras.get(type);
-        if (null != releasingCamera) {
-            _cameras.remove(type);
-            releasingCamera.release();
-        }
-    }
-
-    public int getPreviewWidth(int type) {
-        CameraInfoWrapper cameraInfo = _cameraInfos.get(type);
-        if (null == cameraInfo) {
-            return 0;
-        }
-        return cameraInfo.previewWidth;
-    }
-
-    public int getPreviewHeight(int type) {
-        CameraInfoWrapper cameraInfo = _cameraInfos.get(type);
-        if (null == cameraInfo) {
-            return 0;
-        }
-        return cameraInfo.previewHeight;
-    }
-
-    public int getPreviewVisibleHeight(int type) {
-        CameraInfoWrapper cameraInfo = _cameraInfos.get(type);
-        if (null == cameraInfo) {
-            return 0;
-        }
-        return cameraInfo.previewVisibleHeight;
-    }
-
-    public int getPreviewVisibleWidth(int type) {
-        CameraInfoWrapper cameraInfo = _cameraInfos.get(type);
-        if (null == cameraInfo) {
-            return 0;
-        }
-        return cameraInfo.previewVisibleWidth;
-    }
-
-    public Camera.Size getBestSize(List<Camera.Size> supportedSizes, int maxWidth, int maxHeight) {
-        Camera.Size bestSize = null;
-        for (Camera.Size size : supportedSizes) {
-            if (size.width > maxWidth || size.height > maxHeight) {
-                continue;
-            }
-
-            if (bestSize == null) {
-                bestSize = size;
-                continue;
-            }
-
-            int resultArea = bestSize.width * bestSize.height;
-            int newArea = size.width * size.height;
-
-            if (newArea > resultArea) {
-                bestSize = size;
-            }
-        }
-
-        return bestSize;
-    }
-
-    private Camera.Size getSmallestSize(List<Camera.Size> supportedSizes) {
-        Camera.Size smallestSize = null;
-        for (Camera.Size size : supportedSizes) {
-            if (smallestSize == null) {
-                smallestSize = size;
-                continue;
-            }
-
-            int resultArea = smallestSize.width * smallestSize.height;
-            int newArea = size.width * size.height;
-
-            if (newArea < resultArea) {
-                smallestSize = size;
-            }
-        }
-
-        return smallestSize;
-    }
-
-    private Camera.Size getClosestSize(List<Camera.Size> supportedSizes, int matchWidth, int matchHeight) {
-      Camera.Size closestSize = null;
-      for (Camera.Size size : supportedSizes) {
-          if (closestSize == null) {
-              closestSize = size;
-              continue;
-          }
-
-          double currentDelta = Math.sqrt(Math.pow(closestSize.width - matchWidth,2) + Math.pow(closestSize.height - matchHeight,2));
-          double newDelta = Math.sqrt(Math.pow(size.width - matchWidth,2) + Math.pow(size.height - matchHeight,2));
-
-          if (newDelta < currentDelta) {
-              closestSize = size;
-          }
-      }
-      return closestSize;
-    }
-
-    protected List<Camera.Size> getSupportedVideoSizes(Camera camera) {
-        Camera.Parameters params = camera.getParameters();
-        // defer to preview instead of params.getSupportedVideoSizes() http://bit.ly/1rxOsq0
-        // but prefer SupportedVideoSizes!
-        List<Camera.Size> sizes = params.getSupportedVideoSizes();
-        if (sizes != null) {
-            return sizes;
-        }
-
-        // Video sizes may be null, which indicates that all the supported
-        // preview sizes are supported for video recording.
-        return params.getSupportedPreviewSizes();
-    }
-
-    public int getOrientation() {
-        return _orientation;
-    }
-
-    public void setOrientation(int orientation) {
-        if (_orientation == orientation) {
-            return;
-        }
-        _orientation = orientation;
-        adjustPreviewLayout(RCTCameraModule.RCT_CAMERA_TYPE_FRONT);
-        adjustPreviewLayout(RCTCameraModule.RCT_CAMERA_TYPE_BACK);
-    }
-
-    public boolean isBarcodeScannerEnabled() {
-      return _barcodeScannerEnabled;
-    }
-
-    public void setBarcodeScannerEnabled(boolean barcodeScannerEnabled) {
-        _barcodeScannerEnabled = barcodeScannerEnabled;
-    }
-
-    public List<String> getBarCodeTypes() {
-        return _barCodeTypes;
-    }
-
-    public void setBarCodeTypes(List<String> barCodeTypes) {
-        _barCodeTypes = barCodeTypes;
-    }
-
-    public int getActualDeviceOrientation() {
-        return _actualDeviceOrientation;
-    }
-
-    public void setAdjustedDeviceOrientation(int orientation) {
-        _adjustedDeviceOrientation = orientation;
-    }
-
-    public int getAdjustedDeviceOrientation() {
-        return _adjustedDeviceOrientation;
-    }
-
-    public void setActualDeviceOrientation(int actualDeviceOrientation) {
-        _actualDeviceOrientation = actualDeviceOrientation;
-        adjustPreviewLayout(RCTCameraModule.RCT_CAMERA_TYPE_FRONT);
-        adjustPreviewLayout(RCTCameraModule.RCT_CAMERA_TYPE_BACK);
-    }
-
-    public void setCaptureMode(final int cameraType, final int captureMode) {
-        Camera camera = _cameras.get(cameraType);
-        if (camera == null) {
-            return;
-        }
-
-        // Set (video) recording hint based on camera type. For video recording, setting
-        // this hint can help reduce the time it takes to start recording.
-        Camera.Parameters parameters = camera.getParameters();
-        parameters.setRecordingHint(captureMode == RCTCameraModule.RCT_CAMERA_CAPTURE_MODE_VIDEO);
-        try{
-          camera.setParameters(parameters);
-        }
-        catch(RuntimeException e ) {
-          Log.e("RCTCamera", "setParameters failed", e);
-        }
-    }
-
-    public void setCaptureQuality(int cameraType, String captureQuality) {
-        Camera camera = this.acquireCameraInstance(cameraType);
-        if (camera == null) {
-            return;
-        }
-
-        Camera.Parameters parameters = camera.getParameters();
-        Camera.Size pictureSize = null;
-        List<Camera.Size> supportedSizes = parameters.getSupportedPictureSizes();
-        switch (captureQuality) {
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_LOW:
-                pictureSize = getSmallestSize(supportedSizes);
-                break;
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_MEDIUM:
-                pictureSize = supportedSizes.get(supportedSizes.size() / 2);
-                break;
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_HIGH:
-                pictureSize = getBestSize(parameters.getSupportedPictureSizes(), Integer.MAX_VALUE, Integer.MAX_VALUE);
-                break;
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_PREVIEW:
-                Camera.Size optimalPreviewSize = getBestSize(parameters.getSupportedPreviewSizes(), Integer.MAX_VALUE, Integer.MAX_VALUE);
-                pictureSize = getClosestSize(parameters.getSupportedPictureSizes(), optimalPreviewSize.width, optimalPreviewSize.height);
-                break;
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_480P:
-                pictureSize = getBestSize(supportedSizes, RESOLUTION_480P.width, RESOLUTION_480P.height);
-                break;
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_720P:
-                pictureSize = getBestSize(supportedSizes, RESOLUTION_720P.width, RESOLUTION_720P.height);
-                break;
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_1080P:
-                pictureSize = getBestSize(supportedSizes, RESOLUTION_1080P.width, RESOLUTION_1080P.height);
-                break;
-        }
-
-        if (pictureSize != null) {
-            parameters.setPictureSize(pictureSize.width, pictureSize.height);
-            try{
-            camera.setParameters(parameters);
-            }
-            catch(RuntimeException e ) {
-              Log.e("RCTCamera", "setParameters failed", e);
-            }
-        }
-    }
-
-    public CamcorderProfile setCaptureVideoQuality(int cameraType, String captureQuality) {
-        Camera camera = this.acquireCameraInstance(cameraType);
-        if (camera == null) {
-            return null;
-        }
-
-        Camera.Size videoSize = null;
-        List<Camera.Size> supportedSizes = getSupportedVideoSizes(camera);
-        CamcorderProfile cm = null;
-        switch (captureQuality) {
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_LOW:
-                videoSize = getSmallestSize(supportedSizes);
-                cm = CamcorderProfile.get(_cameraTypeToIndex.get(cameraType), CamcorderProfile.QUALITY_480P);
-                break;
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_MEDIUM:
-                videoSize = supportedSizes.get(supportedSizes.size() / 2);
-                cm = CamcorderProfile.get(_cameraTypeToIndex.get(cameraType), CamcorderProfile.QUALITY_720P);
-                break;
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_HIGH:
-                videoSize = getBestSize(supportedSizes, Integer.MAX_VALUE, Integer.MAX_VALUE);
-                cm = CamcorderProfile.get(_cameraTypeToIndex.get(cameraType), CamcorderProfile.QUALITY_HIGH);
-                break;
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_480P:
-                videoSize = getBestSize(supportedSizes, RESOLUTION_480P.width, RESOLUTION_480P.height);
-                cm = CamcorderProfile.get(_cameraTypeToIndex.get(cameraType), CamcorderProfile.QUALITY_480P);
-                break;
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_720P:
-                videoSize = getBestSize(supportedSizes, RESOLUTION_720P.width, RESOLUTION_720P.height);
-                cm = CamcorderProfile.get(_cameraTypeToIndex.get(cameraType), CamcorderProfile.QUALITY_720P);
-                break;
-            case RCTCameraModule.RCT_CAMERA_CAPTURE_QUALITY_1080P:
-                videoSize = getBestSize(supportedSizes, RESOLUTION_1080P.width, RESOLUTION_1080P.height);
-                cm = CamcorderProfile.get(_cameraTypeToIndex.get(cameraType), CamcorderProfile.QUALITY_1080P);
-                break;
-        }
-
-        if (cm == null){
-            return null;
-        }
-
-        if (videoSize != null) {
-            cm.videoFrameHeight = videoSize.height;
-            cm.videoFrameWidth = videoSize.width;
-        }
-
-        return cm;
-    }
-
-    public void setTorchMode(int cameraType, int torchMode) {
-        Camera camera = this.acquireCameraInstance(cameraType);
-        if (null == camera) {
-            return;
-        }
-
-        Camera.Parameters parameters = camera.getParameters();
-        String value = parameters.getFlashMode();
-        switch (torchMode) {
-            case RCTCameraModule.RCT_CAMERA_TORCH_MODE_ON:
-                value = Camera.Parameters.FLASH_MODE_TORCH;
-                break;
-            case RCTCameraModule.RCT_CAMERA_TORCH_MODE_OFF:
-                value = Camera.Parameters.FLASH_MODE_OFF;
-                break;
-        }
-
-        List<String> flashModes = parameters.getSupportedFlashModes();
-        if (flashModes != null && flashModes.contains(value)) {
-            parameters.setFlashMode(value);
-            try{
-              camera.setParameters(parameters);
-            }
-          catch(RuntimeException e ) {
-            Log.e("RCTCamera", "setParameters failed", e);
-          }
-        }
-    }
-
-    public void setFlashMode(int cameraType, int flashMode) {
-        Camera camera = this.acquireCameraInstance(cameraType);
-        if (null == camera) {
-            return;
-        }
-
-        Camera.Parameters parameters = camera.getParameters();
-        String value = parameters.getFlashMode();
-        switch (flashMode) {
-            case RCTCameraModule.RCT_CAMERA_FLASH_MODE_AUTO:
-                value = Camera.Parameters.FLASH_MODE_AUTO;
-                break;
-            case RCTCameraModule.RCT_CAMERA_FLASH_MODE_ON:
-                value = Camera.Parameters.FLASH_MODE_ON;
-                break;
-            case RCTCameraModule.RCT_CAMERA_FLASH_MODE_OFF:
-                value = Camera.Parameters.FLASH_MODE_OFF;
-                break;
-        }
-        List<String> flashModes = parameters.getSupportedFlashModes();
-        if (flashModes != null && flashModes.contains(value)) {
-            parameters.setFlashMode(value);
-            try{
-            camera.setParameters(parameters);
-            }
-            catch(RuntimeException e ) {
-              Log.e("RCTCamera", "setParameters failed", e);
-            }
-        }
-    }
-
-    public void setZoom(int cameraType, int zoom) {
-        Camera camera = this.acquireCameraInstance(cameraType);
-        if (null == camera) {
-            return;
-        }
-
-        Camera.Parameters parameters = camera.getParameters();
-        int maxZoom = parameters.getMaxZoom();
-        if (parameters.isZoomSupported()) {
-            if (zoom >=0 && zoom < maxZoom) {
-                parameters.setZoom(zoom);
-                try{
-                  camera.setParameters(parameters);
-                }
-                catch(RuntimeException e ) {
-                  Log.e("RCTCamera", "setParameters failed", e);
-                }
-            }
-        }
-    }
-
-    public void adjustCameraRotationToDeviceOrientation(int type, int deviceOrientation) {
-        Camera camera = _cameras.get(type);
-        if (null == camera) {
-            return;
-        }
-
-        CameraInfoWrapper cameraInfo = _cameraInfos.get(type);
-        int rotation;
-        int orientation = cameraInfo.info.orientation;
-        if (cameraInfo.info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
-            rotation = (orientation + deviceOrientation * 90) % 360;
-        } else {
-            rotation = (orientation - deviceOrientation * 90 + 360) % 360;
-        }
-        cameraInfo.rotation = rotation;
-        Camera.Parameters parameters = camera.getParameters();
-        parameters.setRotation(cameraInfo.rotation);
-
-        try {
-            camera.setParameters(parameters);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-    }
-
-    public void adjustPreviewLayout(int type) {
-        Camera camera = _cameras.get(type);
-        if (null == camera) {
-            return;
-        }
-
-        CameraInfoWrapper cameraInfo = _cameraInfos.get(type);
-        int displayRotation;
-        int rotation;
-        int orientation = cameraInfo.info.orientation;
-        if (cameraInfo.info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT) {
-            rotation = (orientation + _actualDeviceOrientation * 90) % 360;
-            displayRotation = (720 - orientation - _actualDeviceOrientation * 90) % 360;
-        } else {
-            rotation = (orientation - _actualDeviceOrientation * 90 + 360) % 360;
-            displayRotation = rotation;
-        }
-        cameraInfo.rotation = rotation;
-        // TODO: take in account the _orientation prop
-
-        setAdjustedDeviceOrientation(rotation);
-        camera.setDisplayOrientation(displayRotation);
-
-        Camera.Parameters parameters = camera.getParameters();
-        parameters.setRotation(cameraInfo.rotation);
-
-        // set preview size
-        // defaults to highest resolution available
-        Camera.Size optimalPreviewSize = getBestSize(parameters.getSupportedPreviewSizes(), Integer.MAX_VALUE, Integer.MAX_VALUE);
-        int width = optimalPreviewSize.width;
-        int height = optimalPreviewSize.height;
-
-        parameters.setPreviewSize(width, height);
-        try {
-            camera.setParameters(parameters);
-        } catch (Exception e) {
-            e.printStackTrace();
-        }
-
-        if (cameraInfo.rotation == 0 || cameraInfo.rotation == 180) {
-            cameraInfo.previewWidth = width;
-            cameraInfo.previewHeight = height;
-        } else {
-            cameraInfo.previewWidth = height;
-            cameraInfo.previewHeight = width;
-        }
-    }
-
-    public void setPreviewVisibleSize(int type, int width, int height) {
-        CameraInfoWrapper cameraInfo = _cameraInfos.get(type);
-        if (cameraInfo == null) {
-            return;
-        }
-
-        cameraInfo.previewVisibleWidth = width;
-        cameraInfo.previewVisibleHeight = height;
-    }
-
-    private RCTCamera(int deviceOrientation) {
-        _cameras = new HashMap<>();
-        _cameraInfos = new HashMap<>();
-        _cameraTypeToIndex = new HashMap<>();
-
-        _actualDeviceOrientation = deviceOrientation;
-
-        // map camera types to camera indexes and collect cameras properties
-        for (int i = 0; i < Camera.getNumberOfCameras(); i++) {
-            Camera.CameraInfo info = new Camera.CameraInfo();
-            Camera.getCameraInfo(i, info);
-            if (info.facing == Camera.CameraInfo.CAMERA_FACING_FRONT && _cameraInfos.get(RCTCameraModule.RCT_CAMERA_TYPE_FRONT) == null) {
-                _cameraInfos.put(RCTCameraModule.RCT_CAMERA_TYPE_FRONT, new CameraInfoWrapper(info));
-                _cameraTypeToIndex.put(RCTCameraModule.RCT_CAMERA_TYPE_FRONT, i);
-                acquireCameraInstance(RCTCameraModule.RCT_CAMERA_TYPE_FRONT);
-                releaseCameraInstance(RCTCameraModule.RCT_CAMERA_TYPE_FRONT);
-            } else if (info.facing == Camera.CameraInfo.CAMERA_FACING_BACK && _cameraInfos.get(RCTCameraModule.RCT_CAMERA_TYPE_BACK) == null) {
-                _cameraInfos.put(RCTCameraModule.RCT_CAMERA_TYPE_BACK, new CameraInfoWrapper(info));
-                _cameraTypeToIndex.put(RCTCameraModule.RCT_CAMERA_TYPE_BACK, i);
-                acquireCameraInstance(RCTCameraModule.RCT_CAMERA_TYPE_BACK);
-                releaseCameraInstance(RCTCameraModule.RCT_CAMERA_TYPE_BACK);
-            }
-        }
-    }
-
-    private class CameraInfoWrapper {
-        public final Camera.CameraInfo info;
-        public int rotation = 0;
-        public int previewWidth = -1;
-        public int previewHeight = -1;
-        public int previewVisibleWidth = -1;
-        public int previewVisibleHeight = -1;
-
-        public CameraInfoWrapper(Camera.CameraInfo info) {
-            this.info = info;
-        }
-    }
-
-    private static class Resolution {
-        public int width;
-        public int height;
-
-        public Resolution(final int width, final int height) {
-            this.width = width;
-            this.height = height;
-        }
-    }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraModule.java b/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraModule.java
deleted file mode 100644
index d5a8a3d..0000000
--- a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraModule.java
+++ /dev/null
@@ -1,871 +0,0 @@
-/**
- * Created by Fabrice Armisen (farmisen@gmail.com) on 1/4/16.
- * Android video recording support by Marc Johnson (me@marc.mn) 4/2016
- */
-
-package com.lwansbrough.RCTCamera;
-
-import android.content.ContentValues;
-import android.content.res.Configuration;
-import android.hardware.Camera;
-import android.media.*;
-import android.net.Uri;
-import android.os.AsyncTask;
-import android.os.Environment;
-import android.provider.MediaStore;
-import android.util.Base64;
-import android.util.Log;
-import android.view.Surface;
-
-import com.facebook.react.bridge.LifecycleEventListener;
-import com.facebook.react.bridge.Promise;
-import com.facebook.react.bridge.ReactApplicationContext;
-import com.facebook.react.bridge.ReactContextBaseJavaModule;
-import com.facebook.react.bridge.ReactMethod;
-import com.facebook.react.bridge.ReadableMap;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.bridge.WritableNativeMap;
-
-import java.io.*;
-import java.text.SimpleDateFormat;
-import java.util.Collections;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import javax.annotation.Nullable;
-
-public class RCTCameraModule extends ReactContextBaseJavaModule
-    implements MediaRecorder.OnInfoListener, MediaRecorder.OnErrorListener, LifecycleEventListener {
-    private static final String TAG = "RCTCameraModule";
-
-    public static final int RCT_CAMERA_ASPECT_FILL = 0;
-    public static final int RCT_CAMERA_ASPECT_FIT = 1;
-    public static final int RCT_CAMERA_ASPECT_STRETCH = 2;
-    public static final int RCT_CAMERA_CAPTURE_MODE_STILL = 0;
-    public static final int RCT_CAMERA_CAPTURE_MODE_VIDEO = 1;
-    public static final int RCT_CAMERA_CAPTURE_TARGET_MEMORY = 0;
-    public static final int RCT_CAMERA_CAPTURE_TARGET_DISK = 1;
-    public static final int RCT_CAMERA_CAPTURE_TARGET_CAMERA_ROLL = 2;
-    public static final int RCT_CAMERA_CAPTURE_TARGET_TEMP = 3;
-    public static final int RCT_CAMERA_ORIENTATION_AUTO = Integer.MAX_VALUE;
-    public static final int RCT_CAMERA_ORIENTATION_PORTRAIT = Surface.ROTATION_0;
-    public static final int RCT_CAMERA_ORIENTATION_PORTRAIT_UPSIDE_DOWN = Surface.ROTATION_180;
-    public static final int RCT_CAMERA_ORIENTATION_LANDSCAPE_LEFT = Surface.ROTATION_90;
-    public static final int RCT_CAMERA_ORIENTATION_LANDSCAPE_RIGHT = Surface.ROTATION_270;
-    public static final int RCT_CAMERA_TYPE_FRONT = 1;
-    public static final int RCT_CAMERA_TYPE_BACK = 2;
-    public static final int RCT_CAMERA_FLASH_MODE_OFF = 0;
-    public static final int RCT_CAMERA_FLASH_MODE_ON = 1;
-    public static final int RCT_CAMERA_FLASH_MODE_AUTO = 2;
-    public static final int RCT_CAMERA_TORCH_MODE_OFF = 0;
-    public static final int RCT_CAMERA_TORCH_MODE_ON = 1;
-    public static final int RCT_CAMERA_TORCH_MODE_AUTO = 2;
-    public static final String RCT_CAMERA_CAPTURE_QUALITY_PREVIEW = "preview";
-    public static final String RCT_CAMERA_CAPTURE_QUALITY_HIGH = "high";
-    public static final String RCT_CAMERA_CAPTURE_QUALITY_MEDIUM = "medium";
-    public static final String RCT_CAMERA_CAPTURE_QUALITY_LOW = "low";
-    public static final String RCT_CAMERA_CAPTURE_QUALITY_1080P = "1080p";
-    public static final String RCT_CAMERA_CAPTURE_QUALITY_720P = "720p";
-    public static final String RCT_CAMERA_CAPTURE_QUALITY_480P = "480p";
-    public static final int MEDIA_TYPE_IMAGE = 1;
-    public static final int MEDIA_TYPE_VIDEO = 2;
-
-    private static ReactApplicationContext _reactContext;
-    private RCTSensorOrientationChecker _sensorOrientationChecker;
-
-    private MediaRecorder mMediaRecorder;
-    private long MRStartTime;
-    private File mVideoFile;
-    private Camera mCamera = null;
-    private Promise mRecordingPromise = null;
-    private ReadableMap mRecordingOptions;
-    private Boolean mSafeToCapture = true;
-
-    public RCTCameraModule(ReactApplicationContext reactContext) {
-        super(reactContext);
-        _reactContext = reactContext;
-        _sensorOrientationChecker = new RCTSensorOrientationChecker(_reactContext);
-        _reactContext.addLifecycleEventListener(this);
-    }
-
-    public static ReactApplicationContext getReactContextSingleton() {
-      return _reactContext;
-    }
-
-    /**
-     * Callback invoked on new MediaRecorder info.
-     *
-     * See https://developer.android.com/reference/android/media/MediaRecorder.OnInfoListener.html
-     * for more information.
-     *
-     * @param mr MediaRecorder instance for which this callback is being invoked.
-     * @param what Type of info we have received.
-     * @param extra Extra code, specific to the info type.
-     */
-    public void onInfo(MediaRecorder mr, int what, int extra) {
-        if ( what == MediaRecorder.MEDIA_RECORDER_INFO_MAX_DURATION_REACHED ||
-                what == MediaRecorder.MEDIA_RECORDER_INFO_MAX_FILESIZE_REACHED) {
-            if (mRecordingPromise != null) {
-                releaseMediaRecorder(); // release the MediaRecorder object and resolve promise
-            }
-        }
-    }
-
-    /**
-     * Callback invoked when a MediaRecorder instance encounters an error while recording.
-     *
-     * See https://developer.android.com/reference/android/media/MediaRecorder.OnErrorListener.html
-     * for more information.
-     *
-     * @param mr MediaRecorder instance for which this callback is being invoked.
-     * @param what Type of error that has occurred.
-     * @param extra Extra code, specific to the error type.
-     */
-    public void onError(MediaRecorder mr, int what, int extra) {
-        // On any error, release the MediaRecorder object and resolve promise. In particular, this
-        // prevents leaving the camera in an unrecoverable state if we crash in the middle of
-        // recording.
-        if (mRecordingPromise != null) {
-            releaseMediaRecorder();
-        }
-    }
-
-    @Override
-    public String getName() {
-        return "RCTCameraModule";
-    }
-
-    @Nullable
-    @Override
-    public Map<String, Object> getConstants() {
-        return Collections.unmodifiableMap(new HashMap<String, Object>() {
-            {
-                put("Aspect", getAspectConstants());
-                put("BarCodeType", getBarCodeConstants());
-                put("Type", getTypeConstants());
-                put("CaptureQuality", getCaptureQualityConstants());
-                put("CaptureMode", getCaptureModeConstants());
-                put("CaptureTarget", getCaptureTargetConstants());
-                put("Orientation", getOrientationConstants());
-                put("FlashMode", getFlashModeConstants());
-                put("TorchMode", getTorchModeConstants());
-            }
-
-            private Map<String, Object> getAspectConstants() {
-                return Collections.unmodifiableMap(new HashMap<String, Object>() {
-                    {
-                        put("stretch", RCT_CAMERA_ASPECT_STRETCH);
-                        put("fit", RCT_CAMERA_ASPECT_FIT);
-                        put("fill", RCT_CAMERA_ASPECT_FILL);
-                    }
-                });
-            }
-
-            private Map<String, Object> getBarCodeConstants() {
-                return Collections.unmodifiableMap(new HashMap<String, Object>() {
-                    {
-                        // @TODO add barcode types
-                    }
-                });
-            }
-
-            private Map<String, Object> getTypeConstants() {
-                return Collections.unmodifiableMap(new HashMap<String, Object>() {
-                    {
-                        put("front", RCT_CAMERA_TYPE_FRONT);
-                        put("back", RCT_CAMERA_TYPE_BACK);
-                    }
-                });
-            }
-
-            private Map<String, Object> getCaptureQualityConstants() {
-                return Collections.unmodifiableMap(new HashMap<String, Object>() {
-                    {
-                        put("low", RCT_CAMERA_CAPTURE_QUALITY_LOW);
-                        put("medium", RCT_CAMERA_CAPTURE_QUALITY_MEDIUM);
-                        put("high", RCT_CAMERA_CAPTURE_QUALITY_HIGH);
-                        put("photo", RCT_CAMERA_CAPTURE_QUALITY_HIGH);
-                        put("preview", RCT_CAMERA_CAPTURE_QUALITY_PREVIEW);
-                        put("480p", RCT_CAMERA_CAPTURE_QUALITY_480P);
-                        put("720p", RCT_CAMERA_CAPTURE_QUALITY_720P);
-                        put("1080p", RCT_CAMERA_CAPTURE_QUALITY_1080P);
-                    }
-                });
-            }
-
-            private Map<String, Object> getCaptureModeConstants() {
-                return Collections.unmodifiableMap(new HashMap<String, Object>() {
-                    {
-                        put("still", RCT_CAMERA_CAPTURE_MODE_STILL);
-                        put("video", RCT_CAMERA_CAPTURE_MODE_VIDEO);
-                    }
-                });
-            }
-
-            private Map<String, Object> getCaptureTargetConstants() {
-                return Collections.unmodifiableMap(new HashMap<String, Object>() {
-                    {
-                        put("memory", RCT_CAMERA_CAPTURE_TARGET_MEMORY);
-                        put("disk", RCT_CAMERA_CAPTURE_TARGET_DISK);
-                        put("cameraRoll", RCT_CAMERA_CAPTURE_TARGET_CAMERA_ROLL);
-                        put("temp", RCT_CAMERA_CAPTURE_TARGET_TEMP);
-                    }
-                });
-            }
-
-            private Map<String, Object> getOrientationConstants() {
-                return Collections.unmodifiableMap(new HashMap<String, Object>() {
-                    {
-                        put("auto", RCT_CAMERA_ORIENTATION_AUTO);
-                        put("landscapeLeft", RCT_CAMERA_ORIENTATION_LANDSCAPE_LEFT);
-                        put("landscapeRight", RCT_CAMERA_ORIENTATION_LANDSCAPE_RIGHT);
-                        put("portrait", RCT_CAMERA_ORIENTATION_PORTRAIT);
-                        put("portraitUpsideDown", RCT_CAMERA_ORIENTATION_PORTRAIT_UPSIDE_DOWN);
-                    }
-                });
-            }
-
-            private Map<String, Object> getFlashModeConstants() {
-                return Collections.unmodifiableMap(new HashMap<String, Object>() {
-                    {
-                        put("off", RCT_CAMERA_FLASH_MODE_OFF);
-                        put("on", RCT_CAMERA_FLASH_MODE_ON);
-                        put("auto", RCT_CAMERA_FLASH_MODE_AUTO);
-                    }
-                });
-            }
-
-            private Map<String, Object> getTorchModeConstants() {
-                return Collections.unmodifiableMap(new HashMap<String, Object>() {
-                    {
-                        put("off", RCT_CAMERA_TORCH_MODE_OFF);
-                        put("on", RCT_CAMERA_TORCH_MODE_ON);
-                        put("auto", RCT_CAMERA_TORCH_MODE_AUTO);
-                    }
-                });
-            }
-        });
-    }
-
-    /**
-     * Prepare media recorder for video capture.
-     *
-     * See "Capturing Videos" at https://developer.android.com/guide/topics/media/camera.html for
-     * a guideline of steps and more information in general.
-     *
-     * @param options Options.
-     * @return Throwable; null if no errors.
-     */
-    private Throwable prepareMediaRecorder(ReadableMap options, int deviceOrientation) {
-        // Prepare CamcorderProfile instance, setting essential options.
-        CamcorderProfile cm = RCTCamera.getInstance().setCaptureVideoQuality(options.getInt("type"), options.getString("quality"));
-        if (cm == null) {
-            return new RuntimeException("CamcorderProfile not found in prepareMediaRecorder.");
-        }
-
-        // Unlock camera to make available for MediaRecorder. Note that this statement must be
-        // executed before calling setCamera when configuring the MediaRecorder instance.
-        mCamera.unlock();
-
-        // Create new MediaRecorder instance.
-        mMediaRecorder = new MediaRecorder();
-
-        // Attach callback to handle maxDuration (@see onInfo method in this file).
-        mMediaRecorder.setOnInfoListener(this);
-        // Attach error listener (@see onError method in this file).
-        mMediaRecorder.setOnErrorListener(this);
-
-        // Set camera.
-        mMediaRecorder.setCamera(mCamera);
-
-        // Set AV sources.
-        mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.CAMCORDER);
-        mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.CAMERA);
-
-        // Adjust for orientation.
-        // mMediaRecorder.setOrientationHint(RCTCamera.getInstance().getAdjustedDeviceOrientation());
-        switch (deviceOrientation) {
-            case 0: mMediaRecorder.setOrientationHint(90);
-              break;
-            case 1: mMediaRecorder.setOrientationHint(0);
-              break;
-            case 2: mMediaRecorder.setOrientationHint(270);
-              break;
-            case 3: mMediaRecorder.setOrientationHint(180);
-              break;
-          }
-
-        // Set video output format and encoding using CamcorderProfile.
-        cm.fileFormat = MediaRecorder.OutputFormat.MPEG_4;
-        mMediaRecorder.setProfile(cm);
-
-        // Set video output file.
-        mVideoFile = null;
-        switch (options.getInt("target")) {
-            case RCT_CAMERA_CAPTURE_TARGET_MEMORY:
-                mVideoFile = getTempMediaFile(MEDIA_TYPE_VIDEO); // temporarily
-                break;
-            case RCT_CAMERA_CAPTURE_TARGET_CAMERA_ROLL:
-                mVideoFile = getOutputCameraRollFile(MEDIA_TYPE_VIDEO);
-                break;
-            case RCT_CAMERA_CAPTURE_TARGET_TEMP:
-                mVideoFile = getTempMediaFile(MEDIA_TYPE_VIDEO);
-                break;
-            default:
-            case RCT_CAMERA_CAPTURE_TARGET_DISK:
-                mVideoFile = getOutputMediaFile(MEDIA_TYPE_VIDEO);
-                break;
-        }
-        if (mVideoFile == null) {
-            return new RuntimeException("Error while preparing output file in prepareMediaRecorder.");
-        }
-        mMediaRecorder.setOutputFile(mVideoFile.getPath());
-
-        if (options.hasKey("totalSeconds")) {
-            int totalSeconds = options.getInt("totalSeconds");
-            mMediaRecorder.setMaxDuration(totalSeconds * 1000);
-        }
-
-        if (options.hasKey("maxFileSize")) {
-            int maxFileSize = options.getInt("maxFileSize");
-            mMediaRecorder.setMaxFileSize(maxFileSize);
-        }
-
-        // Prepare the MediaRecorder instance with the provided configuration settings.
-        try {
-            mMediaRecorder.prepare();
-        } catch (Exception ex) {
-            Log.e(TAG, "Media recorder prepare error.", ex);
-            releaseMediaRecorder();
-            return ex;
-        }
-
-        return null;
-    }
-
-    private void record(final ReadableMap options, final Promise promise, final int deviceOrientation) {
-        if (mRecordingPromise != null) {
-            return;
-        }
-
-        mCamera = RCTCamera.getInstance().acquireCameraInstance(options.getInt("type"));
-        if (mCamera == null) {
-            promise.reject(new RuntimeException("No camera found."));
-            return;
-        }
-
-        Throwable prepareError = prepareMediaRecorder(options, deviceOrientation);
-        if (prepareError != null) {
-            promise.reject(prepareError);
-            return;
-        }
-
-        try {
-            mMediaRecorder.start();
-            MRStartTime =  System.currentTimeMillis();
-            mRecordingOptions = options;
-            mRecordingPromise = promise;  // only got here if mediaRecorder started
-        } catch (Exception ex) {
-            Log.e(TAG, "Media recorder start error.", ex);
-            promise.reject(ex);
-        }
-    }
-
-    /**
-     * Release media recorder following video capture (or failure to start recording session).
-     *
-     * See "Capturing Videos" at https://developer.android.com/guide/topics/media/camera.html for
-     * a guideline of steps and more information in general.
-     */
-    private void releaseMediaRecorder() {
-        // Must record at least a second or MediaRecorder throws exceptions on some platforms
-        long duration = System.currentTimeMillis() - MRStartTime;
-        if (duration < 1500) {
-            try {
-                Thread.sleep(1500 - duration);
-            } catch(InterruptedException ex) {
-                Log.e(TAG, "releaseMediaRecorder thread sleep error.", ex);
-            }
-        }
-
-        // Release actual MediaRecorder instance.
-        if (mMediaRecorder != null) {
-            // Stop recording video.
-            try {
-                mMediaRecorder.stop(); // stop the recording
-            } catch (RuntimeException ex) {
-                Log.e(TAG, "Media recorder stop error.", ex);
-            }
-
-            // Optionally, remove the configuration settings from the recorder.
-            mMediaRecorder.reset();
-
-            // Release the MediaRecorder.
-            mMediaRecorder.release();
-
-            // Reset variable.
-            mMediaRecorder = null;
-        }
-
-        // Lock the camera so that future MediaRecorder sessions can use it by calling
-        // Camera.lock(). Note this is not required on Android 4.0+ unless the
-        // MediaRecorder.prepare() call fails.
-        if (mCamera != null) {
-            mCamera.lock();
-        }
-
-        if (mRecordingPromise == null) {
-            return;
-        }
-
-        File f = new File(mVideoFile.getPath());
-        if (!f.exists()) {
-            mRecordingPromise.reject(new RuntimeException("There is nothing recorded."));
-            mRecordingPromise = null;
-            return;
-        }
-
-        f.setReadable(true, false); // so mediaplayer can play it
-        f.setWritable(true, false); // so can clean it up
-
-        WritableMap response = new WritableNativeMap();
-        switch (mRecordingOptions.getInt("target")) {
-            case RCT_CAMERA_CAPTURE_TARGET_MEMORY:
-                byte[] encoded = convertFileToByteArray(mVideoFile);
-                response.putString("data", new String(encoded, Base64.NO_WRAP));
-                mRecordingPromise.resolve(response);
-                f.delete();
-                break;
-            case RCT_CAMERA_CAPTURE_TARGET_CAMERA_ROLL:
-                ContentValues values = new ContentValues();
-                values.put(MediaStore.Video.Media.DATA, mVideoFile.getPath());
-                values.put(MediaStore.Video.Media.TITLE, mRecordingOptions.hasKey("title") ? mRecordingOptions.getString("title") : "video");
-
-                if (mRecordingOptions.hasKey("description")) {
-                    values.put(MediaStore.Video.Media.DESCRIPTION, mRecordingOptions.hasKey("description"));
-                }
-
-                if (mRecordingOptions.hasKey("latitude")) {
-                    values.put(MediaStore.Video.Media.LATITUDE, mRecordingOptions.getString("latitude"));
-                }
-
-                if (mRecordingOptions.hasKey("longitude")) {
-                    values.put(MediaStore.Video.Media.LONGITUDE, mRecordingOptions.getString("longitude"));
-                }
-
-                values.put(MediaStore.Video.Media.MIME_TYPE, "video/mp4");
-                _reactContext.getContentResolver().insert(MediaStore.Video.Media.EXTERNAL_CONTENT_URI, values);
-                addToMediaStore(mVideoFile.getAbsolutePath());
-                response.putString("path", Uri.fromFile(mVideoFile).toString());
-                mRecordingPromise.resolve(response);
-                break;
-            case RCT_CAMERA_CAPTURE_TARGET_TEMP:
-            case RCT_CAMERA_CAPTURE_TARGET_DISK:
-                response.putString("path", Uri.fromFile(mVideoFile).toString());
-                mRecordingPromise.resolve(response);
-        }
-
-        mRecordingPromise = null;
-    }
-
-    public static byte[] convertFileToByteArray(File f)
-    {
-        byte[] byteArray = null;
-        try
-        {
-            InputStream inputStream = new FileInputStream(f);
-            ByteArrayOutputStream bos = new ByteArrayOutputStream();
-            byte[] b = new byte[1024*8];
-            int bytesRead;
-
-            while ((bytesRead = inputStream.read(b)) != -1) {
-                bos.write(b, 0, bytesRead);
-            }
-
-            byteArray = bos.toByteArray();
-        }
-        catch (IOException e)
-        {
-            e.printStackTrace();
-        }
-        return byteArray;
-    }
-
-    @ReactMethod
-    public void capture(final ReadableMap options, final Promise promise) {
-        if (RCTCamera.getInstance() == null) {
-            promise.reject("Camera is not ready yet.");
-            return;
-        }
-
-        int orientation = options.hasKey("orientation") ? options.getInt("orientation") : RCTCamera.getInstance().getOrientation();
-        if (orientation == RCT_CAMERA_ORIENTATION_AUTO) {
-            _sensorOrientationChecker.onResume();
-            _sensorOrientationChecker.registerOrientationListener(new RCTSensorOrientationListener() {
-                @Override
-                public void orientationEvent() {
-                    int deviceOrientation = _sensorOrientationChecker.getOrientation();
-                    _sensorOrientationChecker.unregisterOrientationListener();
-                    _sensorOrientationChecker.onPause();
-                    captureWithOrientation(options, promise, deviceOrientation);
-                }
-            });
-        } else {
-            captureWithOrientation(options, promise, orientation);
-        }
-    }
-
-    private void captureWithOrientation(final ReadableMap options, final Promise promise, int deviceOrientation) {
-        final Camera camera = RCTCamera.getInstance().acquireCameraInstance(options.getInt("type"));
-        if (null == camera) {
-            promise.reject("No camera found.");
-            return;
-        }
-
-        if (options.getInt("mode") == RCT_CAMERA_CAPTURE_MODE_VIDEO) {
-            record(options, promise, deviceOrientation);
-            return;
-        }
-
-        RCTCamera.getInstance().setCaptureQuality(options.getInt("type"), options.getString("quality"));
-
-        if (options.hasKey("playSoundOnCapture") && options.getBoolean("playSoundOnCapture")) {
-            MediaActionSound sound = new MediaActionSound();
-            sound.play(MediaActionSound.SHUTTER_CLICK);
-        }
-
-        if (options.hasKey("quality")) {
-            RCTCamera.getInstance().setCaptureQuality(options.getInt("type"), options.getString("quality"));
-        }
-
-        RCTCamera.getInstance().adjustCameraRotationToDeviceOrientation(options.getInt("type"), deviceOrientation);
-        camera.setPreviewCallback(null);
-
-        Camera.PictureCallback captureCallback = new Camera.PictureCallback() {
-            @Override
-            public void onPictureTaken(final byte[] data, Camera camera) {
-                camera.stopPreview();
-                camera.startPreview();
-
-                AsyncTask.execute(new Runnable() {
-                    @Override
-                    public void run() {
-                        processImage(new MutableImage(data), options, promise);
-                    }
-                });
-
-                mSafeToCapture = true;
-            }
-        };
-
-        Camera.ShutterCallback shutterCallback = new Camera.ShutterCallback() {
-            @Override
-            public void onShutter() {
-                try {
-                    camera.setPreviewCallback(null);
-                    camera.setPreviewTexture(null);
-                } catch (Exception e) {
-                    e.printStackTrace();
-                }
-            }
-        };
-
-        if(mSafeToCapture) {
-          try {
-            camera.takePicture(shutterCallback, null, captureCallback);
-            mSafeToCapture = false;
-          } catch(RuntimeException ex) {
-              Log.e(TAG, "Couldn't capture photo.", ex);
-          }
-        }
-    }
-
-    /**
-     * synchronized in order to prevent the user crashing the app by taking many photos and them all being processed
-     * concurrently which would blow the memory (esp on smaller devices), and slow things down.
-     */
-    private synchronized void processImage(MutableImage mutableImage, ReadableMap options, Promise promise) {
-        boolean shouldFixOrientation = options.hasKey("fixOrientation") && options.getBoolean("fixOrientation");
-        if(shouldFixOrientation) {
-            try {
-                mutableImage.fixOrientation();
-            } catch (MutableImage.ImageMutationFailedException e) {
-                promise.reject("Error fixing orientation image", e);
-            }
-        }
-
-        boolean needsReorient = false;
-        double previewRatio, pictureRatio = (double) mutableImage.getWidth() / (double) mutableImage.getHeight();
-        try {
-            int type = options.getInt("type");
-            previewRatio = (double) RCTCamera.getInstance().getPreviewVisibleWidth(type) / (double) RCTCamera.getInstance().getPreviewVisibleHeight(type);
-            needsReorient = (previewRatio > 1) != (pictureRatio > 1);
-        } catch (IllegalArgumentException e) {
-            previewRatio = pictureRatio;
-        }
-
-        boolean shouldCropToPreview = options.hasKey("cropToPreview") && options.getBoolean("cropToPreview");
-        if (shouldCropToPreview) {
-            try {
-                mutableImage.cropToPreview(needsReorient ? 1.0 / previewRatio : previewRatio);
-            } catch (IllegalArgumentException e) {
-                promise.reject("Error cropping image to preview", e);
-            }
-        }
-
-        boolean shouldMirror = options.hasKey("mirrorImage") && options.getBoolean("mirrorImage");
-        if (shouldMirror) {
-            try {
-                mutableImage.mirrorImage();
-            } catch (MutableImage.ImageMutationFailedException e) {
-                promise.reject("Error mirroring image", e);
-            }
-        }
-
-        int jpegQualityPercent = 80;
-        if(options.hasKey("jpegQuality")) {
-            jpegQualityPercent = options.getInt("jpegQuality");
-        }
-
-        int imgWidth = (needsReorient) ? mutableImage.getHeight() : mutableImage.getWidth();
-        int imgHeight = (needsReorient) ? mutableImage.getWidth() : mutableImage.getHeight();
-
-        switch (options.getInt("target")) {
-            case RCT_CAMERA_CAPTURE_TARGET_MEMORY:
-                String encoded = mutableImage.toBase64(jpegQualityPercent);
-                WritableMap response = new WritableNativeMap();
-                response.putString("data", encoded);
-                response.putInt("width", imgWidth);
-                response.putInt("height", imgHeight);
-                promise.resolve(response);
-                break;
-            case RCT_CAMERA_CAPTURE_TARGET_CAMERA_ROLL: {
-                File cameraRollFile = getOutputCameraRollFile(MEDIA_TYPE_IMAGE);
-                if (cameraRollFile == null) {
-                    promise.reject("Error creating media file.");
-                    return;
-                }
-
-                try {
-                    mutableImage.writeDataToFile(cameraRollFile, options, jpegQualityPercent);
-                } catch (IOException | NullPointerException e) {
-                    promise.reject("failed to save image file", e);
-                    return;
-                }
-
-                addToMediaStore(cameraRollFile.getAbsolutePath());
-
-                resolveImage(cameraRollFile, imgWidth, imgHeight, promise, true);
-
-                break;
-            }
-            case RCT_CAMERA_CAPTURE_TARGET_DISK: {
-                File pictureFile = getOutputMediaFile(MEDIA_TYPE_IMAGE);
-                if (pictureFile == null) {
-                    promise.reject("Error creating media file.");
-                    return;
-                }
-
-                try {
-                    mutableImage.writeDataToFile(pictureFile, options, jpegQualityPercent);
-                } catch (IOException e) {
-                    promise.reject("failed to save image file", e);
-                    return;
-                }
-
-                resolveImage(pictureFile, imgWidth, imgHeight, promise, false);
-
-                break;
-            }
-            case RCT_CAMERA_CAPTURE_TARGET_TEMP: {
-                File tempFile = getTempMediaFile(MEDIA_TYPE_IMAGE);
-                if (tempFile == null) {
-                    promise.reject("Error creating media file.");
-                    return;
-                }
-
-                try {
-                    mutableImage.writeDataToFile(tempFile, options, jpegQualityPercent);
-                } catch (IOException e) {
-                    promise.reject("failed to save image file", e);
-                    return;
-                }
-
-                resolveImage(tempFile, imgWidth, imgHeight, promise, false);
-
-                break;
-            }
-        }
-    }
-
-    @ReactMethod
-    public void stopCapture(final Promise promise) {
-        if (mRecordingPromise != null) {
-            releaseMediaRecorder(); // release the MediaRecorder object
-            promise.resolve("Finished recording.");
-        } else {
-            promise.resolve("Not recording.");
-        }
-    }
-
-    @ReactMethod
-    public void hasFlash(ReadableMap options, final Promise promise) {
-        Camera camera = RCTCamera.getInstance().acquireCameraInstance(options.getInt("type"));
-        if (null == camera) {
-            promise.reject("No camera found.");
-            return;
-        }
-        List<String> flashModes = camera.getParameters().getSupportedFlashModes();
-        promise.resolve(null != flashModes && !flashModes.isEmpty());
-    }
-
-    @ReactMethod
-    public void setZoom(ReadableMap options, int zoom) {
-        RCTCamera instance = RCTCamera.getInstance();
-        if (instance == null) return;
-
-        Camera camera = instance.acquireCameraInstance(options.getInt("type"));
-        if (camera == null) return;
-
-        Camera.Parameters parameters = camera.getParameters();
-        int maxZoom = parameters.getMaxZoom();
-        if (parameters.isZoomSupported()) {
-            if (zoom >=0 && zoom < maxZoom) {
-                parameters.setZoom(zoom);
-                try{
-                  camera.setParameters(parameters);
-                }
-                catch(RuntimeException e ) {
-                  Log.e("RCTCameraModule", "setParameters failed", e);
-                }
-            }
-        }
-    }
-
-    private File getOutputMediaFile(int type) {
-        // Get environment directory type id from requested media type.
-        String environmentDirectoryType;
-        if (type == MEDIA_TYPE_IMAGE) {
-            environmentDirectoryType = Environment.DIRECTORY_PICTURES;
-        } else if (type == MEDIA_TYPE_VIDEO) {
-            environmentDirectoryType = Environment.DIRECTORY_MOVIES;
-        } else {
-            Log.e(TAG, "Unsupported media type:" + type);
-            return null;
-        }
-
-        return getOutputFile(
-                type,
-                Environment.getExternalStoragePublicDirectory(environmentDirectoryType)
-        );
-    }
-
-    private File getOutputCameraRollFile(int type) {
-        return getOutputFile(
-                type,
-                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM)
-        );
-    }
-
-    private File getOutputFile(int type, File storageDir) {
-        // Create the storage directory if it does not exist
-        if (!storageDir.exists()) {
-            if (!storageDir.mkdirs()) {
-                Log.e(TAG, "failed to create directory:" + storageDir.getAbsolutePath());
-                return null;
-            }
-        }
-
-        // Create a media file name
-        String fileName = String.format("%s", new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date()));
-
-        if (type == MEDIA_TYPE_IMAGE) {
-            fileName = String.format("IMG_%s.jpg", fileName);
-        } else if (type == MEDIA_TYPE_VIDEO) {
-            fileName = String.format("VID_%s.mp4", fileName);
-        } else {
-            Log.e(TAG, "Unsupported media type:" + type);
-            return null;
-        }
-
-        return new File(String.format("%s%s%s", storageDir.getPath(), File.separator, fileName));
-    }
-
-    private File getTempMediaFile(int type) {
-        try {
-            String timeStamp = new SimpleDateFormat("yyyyMMdd_HHmmss").format(new Date());
-            File outputDir = _reactContext.getCacheDir();
-            File outputFile;
-
-            if (type == MEDIA_TYPE_IMAGE) {
-                outputFile = File.createTempFile("IMG_" + timeStamp, ".jpg", outputDir);
-            } else if (type == MEDIA_TYPE_VIDEO) {
-                outputFile = File.createTempFile("VID_" + timeStamp, ".mp4", outputDir);
-            } else {
-                Log.e(TAG, "Unsupported media type:" + type);
-                return null;
-            }
-            return outputFile;
-        } catch (Exception e) {
-            Log.e(TAG, e.getMessage());
-            return null;
-        }
-    }
-
-    private void addToMediaStore(String path) {
-        MediaScannerConnection.scanFile(_reactContext, new String[] { path }, null, null);
-    }
-
-    /**
-     * LifecycleEventListener overrides
-     */
-    @Override
-    public void onHostResume() {
-        mSafeToCapture = true;
-    }
-
-    @Override
-    public void onHostPause() {
-        // On pause, we stop any pending recording session
-        if (mRecordingPromise != null) {
-            releaseMediaRecorder();
-        }
-    }
-
-    @Override
-    public void onHostDestroy() {
-        // ... do nothing
-    }
-
-    private void resolveImage(final File imageFile, final int imgWidth, final int imgHeight, final Promise promise, boolean addToMediaStore) {
-        final WritableMap response = new WritableNativeMap();
-        response.putString("path", Uri.fromFile(imageFile).toString());
-        response.putInt("width", imgWidth);
-        response.putInt("height", imgHeight);
-
-        if(addToMediaStore) {
-            // borrowed from react-native CameraRollManager, it finds and returns the 'internal'
-            // representation of the image uri that was just saved.
-            // e.g. content://media/external/images/media/123
-            MediaScannerConnection.scanFile(
-                    _reactContext,
-                    new String[]{imageFile.getAbsolutePath()},
-                    null,
-                    new MediaScannerConnection.OnScanCompletedListener() {
-                        @Override
-                        public void onScanCompleted(String path, Uri uri) {
-                            if (uri != null) {
-                                response.putString("mediaUri", uri.toString());
-                            }
-
-                            promise.resolve(response);
-                        }
-                    });
-        } else {
-            promise.resolve(response);
-        }
-    }
-
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraUtils.java b/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraUtils.java
deleted file mode 100644
index ffac854..0000000
--- a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraUtils.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package com.lwansbrough.RCTCamera;
-
-import android.graphics.Rect;
-import android.graphics.RectF;
-import android.hardware.Camera;
-import android.view.MotionEvent;
-
-public class RCTCameraUtils {
-    private static final int FOCUS_AREA_MOTION_EVENT_EDGE_LENGTH = 100;
-    private static final int FOCUS_AREA_WEIGHT = 1000;
-
-    /**
-     * Computes a Camera.Area corresponding to the new focus area to focus the camera on. This is
-     * done by deriving a square around the center of a MotionEvent pointer (with side length equal
-     * to FOCUS_AREA_MOTION_EVENT_EDGE_LENGTH), then transforming this rectangle's/square's
-     * coordinates into the (-1000, 1000) coordinate system used for camera focus areas.
-     *
-     * Also note that we operate on RectF instances for the most part, to avoid any integer
-     * division rounding errors going forward. We only round at the very end for playing into
-     * the final focus areas list.
-     *
-     * @throws RuntimeException if unable to compute valid intersection between MotionEvent region
-     * and SurfaceTexture region.
-     */
-    protected static Camera.Area computeFocusAreaFromMotionEvent(final MotionEvent event, final int surfaceTextureWidth, final int surfaceTextureHeight) {
-        // Get position of first touch pointer.
-        final int pointerId = event.getPointerId(0);
-        final int pointerIndex = event.findPointerIndex(pointerId);
-        final float centerX = event.getX(pointerIndex);
-        final float centerY = event.getY(pointerIndex);
-
-        // Build event rect. Note that coordinates increase right and down, such that left <= right
-        // and top <= bottom.
-        final RectF eventRect = new RectF(
-                centerX - FOCUS_AREA_MOTION_EVENT_EDGE_LENGTH, // left
-                centerY - FOCUS_AREA_MOTION_EVENT_EDGE_LENGTH, // top
-                centerX + FOCUS_AREA_MOTION_EVENT_EDGE_LENGTH, // right
-                centerY + FOCUS_AREA_MOTION_EVENT_EDGE_LENGTH // bottom
-        );
-
-        // Intersect this rect with the rect corresponding to the full area of the parent surface
-        // texture, making sure we are not placing any amount of the eventRect outside the parent
-        // surface's area.
-        final RectF surfaceTextureRect = new RectF(
-                (float) 0, // left
-                (float) 0, // top
-                (float) surfaceTextureWidth, // right
-                (float) surfaceTextureHeight // bottom
-        );
-        final boolean intersectSuccess = eventRect.intersect(surfaceTextureRect);
-        if (!intersectSuccess) {
-            throw new RuntimeException(
-                    "MotionEvent rect does not intersect with SurfaceTexture rect; unable to " +
-                            "compute focus area"
-            );
-        }
-
-        // Transform into (-1000, 1000) focus area coordinate system. See
-        // https://developer.android.com/reference/android/hardware/Camera.Area.html.
-        // Note that if this is ever changed to a Rect instead of RectF, be cautious of integer
-        // division rounding!
-        final RectF focusAreaRect = new RectF(
-                (eventRect.left / surfaceTextureWidth) * 2000 - 1000, // left
-                (eventRect.top / surfaceTextureHeight) * 2000 - 1000, // top
-                (eventRect.right / surfaceTextureWidth) * 2000 - 1000, // right
-                (eventRect.bottom / surfaceTextureHeight) * 2000 - 1000 // bottom
-        );
-        Rect focusAreaRectRounded = new Rect();
-        focusAreaRect.round(focusAreaRectRounded);
-        return new Camera.Area(focusAreaRectRounded, FOCUS_AREA_WEIGHT);
-    }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraView.java b/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraView.java
deleted file mode 100644
index 587d5b4..0000000
--- a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraView.java
+++ /dev/null
@@ -1,218 +0,0 @@
-/**
- * Created by Fabrice Armisen (farmisen@gmail.com) on 1/3/16.
- */
-
-package com.lwansbrough.RCTCamera;
-
-import android.content.Context;
-import android.hardware.SensorManager;
-import android.view.OrientationEventListener;
-import android.view.ViewGroup;
-import android.view.WindowManager;
-import android.view.View;
-
-import java.util.List;
-
-public class RCTCameraView extends ViewGroup {
-    private final OrientationEventListener _orientationListener;
-    private final Context _context;
-    private RCTCameraViewFinder _viewFinder = null;
-    private int _actualDeviceOrientation = -1;
-    private int _aspect = RCTCameraModule.RCT_CAMERA_ASPECT_FIT;
-    private int _captureMode = RCTCameraModule.RCT_CAMERA_CAPTURE_MODE_STILL;
-    private String _captureQuality = "high";
-    private int _torchMode = -1;
-    private int _flashMode = -1;
-    private int _zoom = 0;
-    private boolean _clearWindowBackground = false;
-
-    public RCTCameraView(Context context) {
-        super(context);
-        this._context = context;
-        RCTCamera.createInstance(getDeviceOrientation(context));
-
-        _orientationListener = new OrientationEventListener(context, SensorManager.SENSOR_DELAY_NORMAL) {
-            @Override
-            public void onOrientationChanged(int orientation) {
-                if (setActualDeviceOrientation(_context)) {
-                    layoutViewFinder();
-                }
-            }
-        };
-
-        if (_orientationListener.canDetectOrientation()) {
-            _orientationListener.enable();
-        } else {
-            _orientationListener.disable();
-        }
-    }
-
-    @Override
-    protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-        layoutViewFinder(left, top, right, bottom);
-    }
-
-    @Override
-    public void onViewAdded(View child) {
-        if (this._viewFinder == child) return;
-        // remove and readd view to make sure it is in the back.
-        // @TODO figure out why there was a z order issue in the first place and fix accordingly.
-        this.removeView(this._viewFinder);
-        this.addView(this._viewFinder, 0);
-    }
-
-    public void setAspect(int aspect) {
-        this._aspect = aspect;
-        layoutViewFinder();
-    }
-
-    public void setCameraType(final int type) {
-        if (null != this._viewFinder) {
-            this._viewFinder.setCameraType(type);
-            RCTCamera.getInstance().adjustPreviewLayout(type);
-        } else {
-            _viewFinder = new RCTCameraViewFinder(_context, type);
-            if (-1 != this._flashMode) {
-                _viewFinder.setFlashMode(this._flashMode);
-            }
-            if (-1 != this._torchMode) {
-                _viewFinder.setTorchMode(this._torchMode);
-            }
-            if (0 != this._zoom) {
-                _viewFinder.setZoom(this._zoom);
-            }
-            _viewFinder.setClearWindowBackground(this._clearWindowBackground);
-            addView(_viewFinder);
-        }
-    }
-
-    public void setCaptureMode(final int captureMode) {
-        this._captureMode = captureMode;
-        if (this._viewFinder != null) {
-            this._viewFinder.setCaptureMode(captureMode);
-        }
-    }
-
-    public void setCaptureQuality(String captureQuality) {
-        this._captureQuality = captureQuality;
-        if (this._viewFinder != null) {
-            this._viewFinder.setCaptureQuality(captureQuality);
-        }
-    }
-
-    public void setTorchMode(int torchMode) {
-        this._torchMode = torchMode;
-        if (this._viewFinder != null) {
-            this._viewFinder.setTorchMode(torchMode);
-        }
-    }
-
-    public void setFlashMode(int flashMode) {
-        this._flashMode = flashMode;
-        if (this._viewFinder != null) {
-            this._viewFinder.setFlashMode(flashMode);
-        }
-    }
-
-    public void setZoom(int zoom) {
-        this._zoom = zoom;
-        if (this._viewFinder != null) {
-            this._viewFinder.setZoom(zoom);
-        }
-    }
-
-    public void setOrientation(int orientation) {
-        RCTCamera.getInstance().setOrientation(orientation);
-        if (this._viewFinder != null) {
-            layoutViewFinder();
-        }
-    }
-
-    public void setBarcodeScannerEnabled(boolean barcodeScannerEnabled) {
-        RCTCamera.getInstance().setBarcodeScannerEnabled(barcodeScannerEnabled);
-    }
-
-    public void setBarCodeTypes(List<String> types) {
-        RCTCamera.getInstance().setBarCodeTypes(types);
-    }
-
-    public void setClearWindowBackground(boolean clearWindowBackground) {
-        this._clearWindowBackground = clearWindowBackground;
-        if (this._viewFinder != null) {
-            this._viewFinder.setClearWindowBackground(clearWindowBackground);
-        }
-    }
-
-    public void stopPreview() {
-        if (_viewFinder == null) return;
-        _viewFinder.stopPreview();
-    }
-
-    public void startPreview() {
-        if (_viewFinder == null) return;
-        _viewFinder.startPreview();
-    }
-
-    private boolean setActualDeviceOrientation(Context context) {
-        int actualDeviceOrientation = getDeviceOrientation(context);
-        if (_actualDeviceOrientation != actualDeviceOrientation) {
-            _actualDeviceOrientation = actualDeviceOrientation;
-            RCTCamera.getInstance().setActualDeviceOrientation(_actualDeviceOrientation);
-            return true;
-        } else {
-            return false;
-        }
-    }
-
-    private int getDeviceOrientation(Context context) {
-        return ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay().getOrientation();
-    }
-
-    private void layoutViewFinder() {
-        layoutViewFinder(this.getLeft(), this.getTop(), this.getRight(), this.getBottom());
-    }
-
-    private void layoutViewFinder(int left, int top, int right, int bottom) {
-        if (null == _viewFinder) {
-            return;
-        }
-        float width = right - left;
-        float height = bottom - top;
-        int viewfinderWidth;
-        int viewfinderHeight;
-        double ratio;
-        switch (this._aspect) {
-            case RCTCameraModule.RCT_CAMERA_ASPECT_FIT:
-                ratio = this._viewFinder.getRatio();
-                if (ratio * height > width) {
-                    viewfinderHeight = (int) (width / ratio);
-                    viewfinderWidth = (int) width;
-                } else {
-                    viewfinderWidth = (int) (ratio * height);
-                    viewfinderHeight = (int) height;
-                }
-                break;
-            case RCTCameraModule.RCT_CAMERA_ASPECT_FILL:
-                ratio = this._viewFinder.getRatio();
-                if (ratio * height < width) {
-                    viewfinderHeight = (int) (width / ratio);
-                    viewfinderWidth = (int) width;
-                } else {
-                    viewfinderWidth = (int) (ratio * height);
-                    viewfinderHeight = (int) height;
-                }
-                break;
-            default:
-                viewfinderWidth = (int) width;
-                viewfinderHeight = (int) height;
-        }
-
-        int viewFinderPaddingX = (int) ((width - viewfinderWidth) / 2);
-        int viewFinderPaddingY = (int) ((height - viewfinderHeight) / 2);
-
-        RCTCamera.getInstance().setPreviewVisibleSize(_viewFinder.getCameraType(), (int) width, (int) height);
-
-        this._viewFinder.layout(viewFinderPaddingX, viewFinderPaddingY, viewFinderPaddingX + viewfinderWidth, viewFinderPaddingY + viewfinderHeight);
-        this.postInvalidate(this.getLeft(), this.getTop(), this.getRight(), this.getBottom());
-    }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraViewFinder.java b/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraViewFinder.java
deleted file mode 100644
index 6caca4d..0000000
--- a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraViewFinder.java
+++ /dev/null
@@ -1,566 +0,0 @@
-/**
- * Created by Fabrice Armisen (farmisen@gmail.com) on 1/3/16.
- */
-
-package com.lwansbrough.RCTCamera;
-
-import android.app.Activity;
-import android.content.Context;
-import android.content.ContextWrapper;
-import android.graphics.Rect;
-import android.graphics.SurfaceTexture;
-import android.hardware.Camera;
-import android.view.MotionEvent;
-import android.view.TextureView;
-import android.os.AsyncTask;
-import android.util.Log;
-
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.ReactContext;
-import com.facebook.react.bridge.WritableArray;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.modules.core.DeviceEventManagerModule;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.EnumMap;
-import java.util.EnumSet;
-
-import com.google.zxing.BarcodeFormat;
-import com.google.zxing.BinaryBitmap;
-import com.google.zxing.DecodeHintType;
-import com.google.zxing.MultiFormatReader;
-import com.google.zxing.PlanarYUVLuminanceSource;
-import com.google.zxing.Result;
-import com.google.zxing.ResultPoint;
-import com.google.zxing.common.HybridBinarizer;
-
-class RCTCameraViewFinder extends TextureView implements TextureView.SurfaceTextureListener, Camera.PreviewCallback {
-    private int _cameraType;
-    private int _captureMode;
-    private SurfaceTexture _surfaceTexture;
-    private int _surfaceTextureWidth;
-    private int _surfaceTextureHeight;
-    private boolean _isStarting;
-    private boolean _isStopping;
-    private Camera _camera;
-    private boolean _clearWindowBackground = false;
-    private float mFingerSpacing;
-
-    // concurrency lock for barcode scanner to avoid flooding the runtime
-    public static volatile boolean barcodeScannerTaskLock = false;
-
-    // reader instance for the barcode scanner
-    private final MultiFormatReader _multiFormatReader = new MultiFormatReader();
-
-    public RCTCameraViewFinder(Context context, int type) {
-        super(context);
-        this.setSurfaceTextureListener(this);
-        this._cameraType = type;
-        this.initBarcodeReader(RCTCamera.getInstance().getBarCodeTypes());
-    }
-
-    @Override
-    public void onSurfaceTextureAvailable(SurfaceTexture surface, int width, int height) {
-        _surfaceTexture = surface;
-        _surfaceTextureWidth = width;
-        _surfaceTextureHeight = height;
-        startCamera();
-    }
-
-    @Override
-    public void onSurfaceTextureSizeChanged(SurfaceTexture surface, int width, int height) {
-        _surfaceTextureWidth = width;
-        _surfaceTextureHeight = height;
-    }
-
-    @Override
-    public boolean onSurfaceTextureDestroyed(SurfaceTexture surface) {
-        _surfaceTexture = null;
-        _surfaceTextureWidth = 0;
-        _surfaceTextureHeight = 0;
-        stopCamera();
-        return true;
-    }
-
-    @Override
-    public void onSurfaceTextureUpdated(SurfaceTexture surface) {
-    }
-
-    public int getCameraType() {
-        return _cameraType;
-    }
-
-    public double getRatio() {
-        int width = RCTCamera.getInstance().getPreviewWidth(this._cameraType);
-        int height = RCTCamera.getInstance().getPreviewHeight(this._cameraType);
-        return ((float) width) / ((float) height);
-    }
-
-    public void setCameraType(final int type) {
-        if (this._cameraType == type) {
-            return;
-        }
-        new Thread(new Runnable() {
-            @Override
-            public void run() {
-                stopPreview();
-                _cameraType = type;
-                startPreview();
-            }
-        }).start();
-    }
-
-    public void setCaptureMode(final int captureMode) {
-        RCTCamera.getInstance().setCaptureMode(_cameraType, captureMode);
-        this._captureMode = captureMode;
-    }
-
-    public void setCaptureQuality(String captureQuality) {
-        RCTCamera.getInstance().setCaptureQuality(_cameraType, captureQuality);
-    }
-
-    public void setTorchMode(int torchMode) {
-        RCTCamera.getInstance().setTorchMode(_cameraType, torchMode);
-    }
-
-    public void setFlashMode(int flashMode) {
-        RCTCamera.getInstance().setFlashMode(_cameraType, flashMode);
-    }
-
-    public void setClearWindowBackground(boolean clearWindowBackground) {
-        this._clearWindowBackground = clearWindowBackground;
-    }
-
-    public void setZoom(int zoom) {
-        RCTCamera.getInstance().setZoom(_cameraType, zoom);
-    }
-
-    public void startPreview() {
-        if (_surfaceTexture != null) {
-            startCamera();
-        }
-    }
-
-    public void stopPreview() {
-        if (_camera != null) {
-            stopCamera();
-        }
-    }
-
-    synchronized private void startCamera() {
-        if (!_isStarting) {
-            _isStarting = true;
-            try {
-                _camera = RCTCamera.getInstance().acquireCameraInstance(_cameraType);
-                Camera.Parameters parameters = _camera.getParameters();
-
-                final boolean isCaptureModeStill = (_captureMode == RCTCameraModule.RCT_CAMERA_CAPTURE_MODE_STILL);
-                final boolean isCaptureModeVideo = (_captureMode == RCTCameraModule.RCT_CAMERA_CAPTURE_MODE_VIDEO);
-                if (!isCaptureModeStill && !isCaptureModeVideo) {
-                    throw new RuntimeException("Unsupported capture mode:" + _captureMode);
-                }
-
-                // Set auto-focus. Try to set to continuous picture/video, and fall back to general
-                // auto if available.
-                List<String> focusModes = parameters.getSupportedFocusModes();
-                if (isCaptureModeStill && focusModes.contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE)) {
-                    parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_PICTURE);
-                } else if (isCaptureModeVideo && focusModes.contains(Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO)) {
-                    parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_CONTINUOUS_VIDEO);
-                } else if (focusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) {
-                    parameters.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
-                }
-
-                // set picture size
-                // defaults to max available size
-                List<Camera.Size> supportedSizes;
-                if (isCaptureModeStill) {
-                    supportedSizes = parameters.getSupportedPictureSizes();
-                } else if (isCaptureModeVideo) {
-                    supportedSizes = RCTCamera.getInstance().getSupportedVideoSizes(_camera);
-                } else {
-                    throw new RuntimeException("Unsupported capture mode:" + _captureMode);
-                }
-                Camera.Size optimalPictureSize = RCTCamera.getInstance().getBestSize(
-                        supportedSizes,
-                        Integer.MAX_VALUE,
-                        Integer.MAX_VALUE
-                );
-                parameters.setPictureSize(optimalPictureSize.width, optimalPictureSize.height);
-
-                try{
-                  _camera.setParameters(parameters);
-                }
-                catch(RuntimeException e ) {
-                  Log.e("RCTCameraViewFinder", "setParameters failed", e);
-                }
-                _camera.setPreviewTexture(_surfaceTexture);
-                _camera.startPreview();
-                // clear window background if needed
-                if (_clearWindowBackground) {
-                    Activity activity = getActivity();
-                    if (activity != null)
-                        activity.getWindow().setBackgroundDrawable(null);
-                }
-                // send previews to `onPreviewFrame`
-                _camera.setPreviewCallback(this);
-            } catch (NullPointerException e) {
-                e.printStackTrace();
-            } catch (Exception e) {
-                e.printStackTrace();
-                stopCamera();
-            } finally {
-                _isStarting = false;
-            }
-        }
-    }
-
-    synchronized private void stopCamera() {
-        if (!_isStopping) {
-            _isStopping = true;
-            try {
-                if (_camera != null) {
-                    _camera.stopPreview();
-                    // stop sending previews to `onPreviewFrame`
-                    _camera.setPreviewCallback(null);
-                    RCTCamera.getInstance().releaseCameraInstance(_cameraType);
-                    _camera = null;
-                }
-
-            } catch (Exception e) {
-                e.printStackTrace();
-            } finally {
-                _isStopping = false;
-            }
-        }
-    }
-
-    private Activity getActivity() {
-        Context context = getContext();
-        while (context instanceof ContextWrapper) {
-            if (context instanceof Activity) {
-                return (Activity)context;
-            }
-            context = ((ContextWrapper)context).getBaseContext();
-        }
-        return null;
-    }
-
-    /**
-     * Parse barcodes as BarcodeFormat constants.
-     *
-     * Supports all iOS codes except [code39mod43, itf14]
-     *
-     * Additionally supports [codabar, maxicode, rss14, rssexpanded, upca, upceanextension]
-     */
-    private BarcodeFormat parseBarCodeString(String c) {
-        if ("aztec".equals(c)) {
-            return BarcodeFormat.AZTEC;
-        } else if ("ean13".equals(c)) {
-            return BarcodeFormat.EAN_13;
-        } else if ("ean8".equals(c)) {
-            return BarcodeFormat.EAN_8;
-        } else if ("qr".equals(c)) {
-            return BarcodeFormat.QR_CODE;
-        } else if ("pdf417".equals(c)) {
-            return BarcodeFormat.PDF_417;
-        } else if ("upce".equals(c)) {
-            return BarcodeFormat.UPC_E;
-        } else if ("datamatrix".equals(c)) {
-            return BarcodeFormat.DATA_MATRIX;
-        } else if ("code39".equals(c)) {
-            return BarcodeFormat.CODE_39;
-        } else if ("code93".equals(c)) {
-            return BarcodeFormat.CODE_93;
-        } else if ("interleaved2of5".equals(c)) {
-            return BarcodeFormat.ITF;
-        } else if ("codabar".equals(c)) {
-            return BarcodeFormat.CODABAR;
-        } else if ("code128".equals(c)) {
-            return BarcodeFormat.CODE_128;
-        } else if ("maxicode".equals(c)) {
-            return BarcodeFormat.MAXICODE;
-        } else if ("rss14".equals(c)) {
-            return BarcodeFormat.RSS_14;
-        } else if ("rssexpanded".equals(c)) {
-            return BarcodeFormat.RSS_EXPANDED;
-        } else if ("upca".equals(c)) {
-            return BarcodeFormat.UPC_A;
-        } else if ("upceanextension".equals(c)) {
-            return BarcodeFormat.UPC_EAN_EXTENSION;
-        } else {
-            android.util.Log.v("RCTCamera", "Unsupported code.. [" + c + "]");
-            return null;
-        }
-    }
-
-    /**
-     * Initialize the barcode decoder.
-     */
-    private void initBarcodeReader(List<String> barCodeTypes) {
-        EnumMap<DecodeHintType, Object> hints = new EnumMap<>(DecodeHintType.class);
-        EnumSet<BarcodeFormat> decodeFormats = EnumSet.noneOf(BarcodeFormat.class);
-
-        if (barCodeTypes != null) {
-            for (String code : barCodeTypes) {
-                BarcodeFormat format = parseBarCodeString(code);
-                if (format != null) {
-                    decodeFormats.add(format);
-                }
-            }
-        }
-
-        hints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);
-        _multiFormatReader.setHints(hints);
-    }
-
-    /**
-     * Spawn a barcode reader task if
-     *  - the barcode scanner is enabled (has a onBarCodeRead function)
-     *  - one isn't already running
-     *
-     * See {Camera.PreviewCallback}
-     */
-    public void onPreviewFrame(byte[] data, Camera camera) {
-        if (RCTCamera.getInstance().isBarcodeScannerEnabled() && !RCTCameraViewFinder.barcodeScannerTaskLock) {
-            RCTCameraViewFinder.barcodeScannerTaskLock = true;
-            new ReaderAsyncTask(camera, data).execute();
-        }
-    }
-
-    private class ReaderAsyncTask extends AsyncTask<Void, Void, Void> {
-        private byte[] imageData;
-        private final Camera camera;
-
-        ReaderAsyncTask(Camera camera, byte[] imageData) {
-            this.camera = camera;
-            this.imageData = imageData;
-        }
-
-        private Result getBarcode(int width, int height, boolean inverse) {
-            try{
-                PlanarYUVLuminanceSource source = new PlanarYUVLuminanceSource(imageData, width, height, 0, 0, width, height, false);
-                BinaryBitmap bitmap;
-                if (inverse) {
-                    bitmap = new BinaryBitmap(new HybridBinarizer(source.invert()));
-                } else {
-                    bitmap = new BinaryBitmap(new HybridBinarizer(source));
-                }
-                return _multiFormatReader.decodeWithState(bitmap);
-            } catch (Throwable t) {
-                // meh
-            } finally {
-                _multiFormatReader.reset();
-            }
-            return null;
-        }
-
-        private Result getBarcodeAnyOrientation() {
-            Camera.Size size = camera.getParameters().getPreviewSize();
-
-            int width = size.width;
-            int height = size.height;
-            Result result = getBarcode(width, height, false);
-            if (result != null) {
-                return result;
-            }
-            // inverse
-            result = getBarcode(width, height, true);
-            if (result != null) {
-                return result;
-            }
-            // rotate
-            rotateImage(width, height);
-            width = size.height;
-            height = size.width;
-            result = getBarcode(width, height, false);
-            if (result != null) {
-                return result;
-            }
-            return getBarcode(width, height, true);
-
-        }
-
-        private void rotateImage(int width, int height) {
-            byte[] rotated = new byte[imageData.length];
-            for (int y = 0; y < width; y++) {
-                for (int x = 0; x < height; x++) {
-                    int sourceIx = x + y * height;
-                    int destIx = x * width + width - y - 1;
-                    if (sourceIx >= 0 && sourceIx < imageData.length && destIx >= 0 && destIx < imageData.length) {
-                        rotated[destIx] = imageData[sourceIx];
-                    }
-                }
-            }
-            imageData = rotated;
-        }
-
-        @Override
-        protected Void doInBackground(Void... ignored) {
-            if (isCancelled()) {
-                return null;
-            }
-
-            try {
-                // rotate for zxing if orientation is portrait
-                Result result = getBarcodeAnyOrientation();
-                if (result == null){
-                    throw new Exception();
-                }
-
-                ReactContext reactContext = RCTCameraModule.getReactContextSingleton();
-                WritableMap event = Arguments.createMap();
-                WritableArray resultPoints = Arguments.createArray();
-                ResultPoint[] points = result.getResultPoints();
-
-                if(points != null) {
-                    for (ResultPoint point : points) {
-                        WritableMap newPoint = Arguments.createMap();
-                        newPoint.putString("x", String.valueOf(point.getX()));
-                        newPoint.putString("y", String.valueOf(point.getY()));
-                        resultPoints.pushMap(newPoint);
-                    }
-                }
-
-                event.putArray("bounds", resultPoints);
-                event.putString("data", result.getText());
-                event.putString("type", result.getBarcodeFormat().toString());
-                reactContext.getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class).emit("CameraBarCodeReadAndroid", event);
-
-            } catch (Throwable t) {
-                // meh
-            } finally {
-                _multiFormatReader.reset();
-                RCTCameraViewFinder.barcodeScannerTaskLock = false;
-                return null;
-            }
-        }
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        // Fast swiping and touching while component is being loaded can cause _camera to be null.
-        if (_camera == null) {
-            return false;
-        }
-
-        // Get the pointer ID
-        Camera.Parameters params = _camera.getParameters();
-        int action = event.getAction();
-
-
-        if (event.getPointerCount() > 1) {
-            // handle multi-touch events
-            if (action == MotionEvent.ACTION_POINTER_DOWN) {
-                mFingerSpacing = getFingerSpacing(event);
-            } else if (action == MotionEvent.ACTION_MOVE && params.isZoomSupported()) {
-                _camera.cancelAutoFocus();
-                handleZoom(event, params);
-            }
-        } else {
-            // handle single touch events
-            if (action == MotionEvent.ACTION_UP) {
-                handleFocus(event, params);
-            }
-        }
-        return true;
-    }
-
-    private void handleZoom(MotionEvent event, Camera.Parameters params) {
-        int maxZoom = params.getMaxZoom();
-        int zoom = params.getZoom();
-        float newDist = getFingerSpacing(event);
-        if (newDist > mFingerSpacing) {
-            //zoom in
-            if (zoom < maxZoom)
-                zoom++;
-        } else if (newDist < mFingerSpacing) {
-            //zoom out
-            if (zoom > 0)
-                zoom--;
-        }
-        mFingerSpacing = newDist;
-        params.setZoom(zoom);
-        try{
-          _camera.setParameters(params);
-        }
-        catch(RuntimeException e ) {
-          Log.e("RCTCameraViewFinder", "setParameters failed", e);
-        }
-    }
-
-    /**
-     * Handles setting focus to the location of the event.
-     *
-     * Note that this will override the focus mode on the camera to FOCUS_MODE_AUTO if available,
-     * even if this was previously something else (such as FOCUS_MODE_CONTINUOUS_*; see also
-     * {@link #startCamera()}. However, this makes sense - after the user has initiated any
-     * specific focus intent, we shouldn't be refocusing and overriding their request!
-     */
-    public void handleFocus(MotionEvent event, Camera.Parameters params) {
-        List<String> supportedFocusModes = params.getSupportedFocusModes();
-        if (supportedFocusModes != null && supportedFocusModes.contains(Camera.Parameters.FOCUS_MODE_AUTO)) {
-            // Ensure focus areas are enabled. If max num focus areas is 0, then focus area is not
-            // supported, so we cannot do anything here.
-            if (params.getMaxNumFocusAreas() == 0) {
-                return;
-            }
-
-            // Cancel any previous focus actions.
-            _camera.cancelAutoFocus();
-
-            // Compute focus area rect.
-            Camera.Area focusAreaFromMotionEvent;
-            try {
-                focusAreaFromMotionEvent = RCTCameraUtils.computeFocusAreaFromMotionEvent(event, _surfaceTextureWidth, _surfaceTextureHeight);
-            } catch (final RuntimeException e) {
-                e.printStackTrace();
-                return;
-            }
-
-            // Set focus mode to auto.
-            params.setFocusMode(Camera.Parameters.FOCUS_MODE_AUTO);
-            // Set focus area.
-            final ArrayList<Camera.Area> focusAreas = new ArrayList<Camera.Area>();
-            focusAreas.add(focusAreaFromMotionEvent);
-            params.setFocusAreas(focusAreas);
-
-            // Also set metering area if enabled. If max num metering areas is 0, then metering area
-            // is not supported. We can usually safely omit this anyway, though.
-            if (params.getMaxNumMeteringAreas() > 0) {
-                params.setMeteringAreas(focusAreas);
-            }
-
-            // Set parameters before starting auto-focus.
-            try{
-              _camera.setParameters(params);
-            }
-            catch(RuntimeException e ) {
-              Log.e("RCTCameraViewFinder", "setParameters failed", e);
-            }
-
-            // Start auto-focus now that focus area has been set. If successful, then can cancel
-            // it afterwards. Wrap in try-catch to avoid crashing on merely autoFocus fails.
-            try {
-                _camera.autoFocus(new Camera.AutoFocusCallback() {
-                    @Override
-                    public void onAutoFocus(boolean success, Camera camera) {
-                        if (success) {
-                            camera.cancelAutoFocus();
-                        }
-                    }
-                });
-            } catch (Exception e) {
-                e.printStackTrace();
-            }
-        }
-    }
-
-    /** Determine the space between the first two fingers */
-    private float getFingerSpacing(MotionEvent event) {
-        float x = event.getX(0) - event.getX(1);
-        float y = event.getY(0) - event.getY(1);
-        return (float) Math.sqrt(x * x + y * y);
-    }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraViewManager.java b/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraViewManager.java
deleted file mode 100644
index 86919a3..0000000
--- a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTCameraViewManager.java
+++ /dev/null
@@ -1,133 +0,0 @@
-package com.lwansbrough.RCTCamera;
-
-import androidx.annotation.Nullable;
-
-import com.facebook.react.bridge.ReadableArray;
-import com.facebook.react.common.MapBuilder;
-import com.facebook.react.uimanager.*;
-import com.facebook.react.uimanager.annotations.ReactProp;
-
-import java.util.List;
-import java.util.ArrayList;
-import java.util.Map;
-
-public class RCTCameraViewManager extends ViewGroupManager<RCTCameraView> {
-    private static final String REACT_CLASS = "RCTCamera";
-
-    public static final int COMMAND_STOP_PREVIEW = 1;
-    public static final int COMMAND_START_PREVIEW = 2;
-
-    @Override
-    public String getName() {
-        return REACT_CLASS;
-    }
-
-    @Override
-    public RCTCameraView createViewInstance(ThemedReactContext context) {
-        return new RCTCameraView(context);
-    }
-
-    @Override
-    public Map<String, Integer> getCommandsMap() {
-        return MapBuilder.of(
-                "stopPreview",
-                COMMAND_STOP_PREVIEW,
-                "startPreview",
-                COMMAND_START_PREVIEW);
-    }
-
-    @Override
-    public void receiveCommand(RCTCameraView view, int commandType, @Nullable ReadableArray args) {
-        if (view == null) {
-            throw new AssertionError();
-        }
-        switch (commandType) {
-            case COMMAND_STOP_PREVIEW: {
-                view.stopPreview();
-                return;
-            }
-            case COMMAND_START_PREVIEW: {
-                view.startPreview();
-                return;
-            }
-            default:
-                throw new IllegalArgumentException(
-                        String.format("Unsupported command %d received by %s.", commandType, getClass().getSimpleName()));
-        }
-    }
-
-    @ReactProp(name = "aspect")
-    public void setAspect(RCTCameraView view, int aspect) {
-        view.setAspect(aspect);
-    }
-
-    @ReactProp(name = "captureMode")
-    public void setCaptureMode(RCTCameraView view, final int captureMode) {
-        // Note that this in practice only performs any additional setup necessary for each mode;
-        // the actual indication to capture a still or record a video when capture() is called is
-        // still ultimately decided upon by what it in the options sent to capture().
-        view.setCaptureMode(captureMode);
-    }
-
-    @ReactProp(name = "captureTarget")
-    public void setCaptureTarget(RCTCameraView view, int captureTarget) {
-        // No reason to handle this props value here since it's passed again to the RCTCameraModule capture method
-    }
-
-    @ReactProp(name = "type")
-    public void setType(RCTCameraView view, int type) {
-        view.setCameraType(type);
-    }
-
-    @ReactProp(name = "captureQuality")
-    public void setCaptureQuality(RCTCameraView view, String captureQuality) {
-        view.setCaptureQuality(captureQuality);
-    }
-
-    @ReactProp(name = "torchMode")
-    public void setTorchMode(RCTCameraView view, int torchMode) {
-        view.setTorchMode(torchMode);
-    }
-
-    @ReactProp(name = "flashMode")
-    public void setFlashMode(RCTCameraView view, int flashMode) {
-        view.setFlashMode(flashMode);
-    }
-
-    @ReactProp(name = "zoom")
-    public void setZoom(RCTCameraView view, int zoom) {
-        view.setZoom(zoom);
-    }
-
-    @ReactProp(name = "orientation")
-    public void setOrientation(RCTCameraView view, int orientation) {
-        view.setOrientation(orientation);
-    }
-
-    @ReactProp(name = "captureAudio")
-    public void setCaptureAudio(RCTCameraView view, boolean captureAudio) {
-        // TODO - implement video mode
-    }
-
-    @ReactProp(name = "barcodeScannerEnabled")
-    public void setBarcodeScannerEnabled(RCTCameraView view, boolean barcodeScannerEnabled) {
-        view.setBarcodeScannerEnabled(barcodeScannerEnabled);
-    }
-
-    @ReactProp(name = "barCodeTypes")
-    public void setBarCodeTypes(RCTCameraView view, ReadableArray barCodeTypes) {
-        if (barCodeTypes == null) {
-            return;
-        }
-        List<String> result = new ArrayList<String>(barCodeTypes.size());
-        for (int i = 0; i < barCodeTypes.size(); i++) {
-            result.add(barCodeTypes.getString(i));
-        }
-        view.setBarCodeTypes(result);
-    }
-
-    @ReactProp(name = "clearWindowBackground")
-    public void setClearWindowBackground(RCTCameraView view, boolean clearWindowBackground) {
-        view.setClearWindowBackground(clearWindowBackground);
-    }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTSensorOrientationChecker.java b/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTSensorOrientationChecker.java
deleted file mode 100644
index 0f57dc8..0000000
--- a/node_modules/react-native-camera/android/src/main/java/com/lwansbrough/RCTCamera/RCTSensorOrientationChecker.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/**
- * Created by rpopovici on 23/03/16.
- */
-
-package com.lwansbrough.RCTCamera;
-
-import android.content.Context;
-import android.hardware.Sensor;
-import android.hardware.SensorEvent;
-import android.hardware.SensorEventListener;
-import android.hardware.SensorManager;
-import android.view.Surface;
-
-import com.facebook.react.bridge.ReactApplicationContext;
-
-interface RCTSensorOrientationListener {
-    void orientationEvent();
-}
-
-public class RCTSensorOrientationChecker {
-
-    int mOrientation = 0;
-    private SensorEventListener mSensorEventListener;
-    private SensorManager mSensorManager;
-    private RCTSensorOrientationListener mListener = null;
-
-    public RCTSensorOrientationChecker( ReactApplicationContext reactContext) {
-        mSensorEventListener = new Listener();
-        mSensorManager = (SensorManager) reactContext.getSystemService(Context.SENSOR_SERVICE);
-
-    }
-
-    /**
-     * Call on activity onResume()
-     */
-    public void onResume() {
-        mSensorManager.registerListener(mSensorEventListener, mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER), SensorManager.SENSOR_DELAY_NORMAL);
-    }
-
-    /**
-     * Call on activity onPause()
-     */
-    public void onPause() {
-        mSensorManager.unregisterListener(mSensorEventListener);
-    }
-
-    private class Listener implements SensorEventListener {
-
-        @Override
-        public void onSensorChanged(SensorEvent event) {
-            float x = event.values[0];
-            float y = event.values[1];
-
-            if (x<5 && x>-5 && y > 5)
-                mOrientation = Surface.ROTATION_0; // portrait
-            else if (x<-5 && y<5 && y>-5)
-                mOrientation = Surface.ROTATION_270; // right
-            else if (x<5 && x>-5 && y<-5)
-                mOrientation = Surface.ROTATION_180; // upside down
-            else if (x>5 && y<5 && y>-5)
-                mOrientation = Surface.ROTATION_90; // left
-
-            if (mListener != null) {
-                mListener.orientationEvent();
-            }
-        }
-
-        @Override
-        public void onAccuracyChanged(Sensor sensor, int accuracy) {
-
-        }
-    }
-
-    public int getOrientation() {
-        return mOrientation;
-    }
-
-    public void registerOrientationListener(RCTSensorOrientationListener listener) {
-        this.mListener = listener;
-    }
-
-    public void unregisterOrientationListener() {
-        mListener = null;
-    }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/CameraModule.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/CameraModule.java
deleted file mode 100644
index 1ce3279..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/CameraModule.java
+++ /dev/null
@@ -1,548 +0,0 @@
-package org.reactnative.camera;
-
-import android.Manifest;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.media.MediaMetadataRetriever;
-import android.os.AsyncTask;
-import android.util.Log;
-import android.widget.Toast;
-
-import com.facebook.react.bridge.*;
-import com.facebook.react.common.build.ReactBuildConfig;
-import com.facebook.react.uimanager.NativeViewHierarchyManager;
-import com.facebook.react.uimanager.UIBlock;
-import com.facebook.react.uimanager.UIManagerModule;
-import com.google.android.cameraview.AspectRatio;
-import com.google.zxing.BarcodeFormat;
-import org.reactnative.barcodedetector.BarcodeFormatUtils;
-import org.reactnative.camera.utils.ScopedContext;
-import org.reactnative.facedetector.RNFaceDetector;
-import com.google.android.cameraview.Size;
-
-import javax.annotation.Nullable;
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Properties;
-import java.util.List;
-import java.util.Map;
-import java.util.HashMap;
-import java.util.Set;
-import java.util.SortedSet;
-
-
-public class CameraModule extends ReactContextBaseJavaModule {
-  private static final String TAG = "CameraModule";
-
-  private ScopedContext mScopedContext;
-  static final int VIDEO_2160P = 0;
-  static final int VIDEO_1080P = 1;
-  static final int VIDEO_720P = 2;
-  static final int VIDEO_480P = 3;
-  static final int VIDEO_4x3 = 4;
-
-  static final int GOOGLE_VISION_BARCODE_MODE_NORMAL = 0;
-  static final int GOOGLE_VISION_BARCODE_MODE_ALTERNATE = 1;
-  static final int GOOGLE_VISION_BARCODE_MODE_INVERTED = 2;
-
-  public static final Map<String, Object> VALID_BARCODE_TYPES =
-      Collections.unmodifiableMap(new HashMap<String, Object>() {
-        {
-          put("aztec", BarcodeFormat.AZTEC.toString());
-          put("ean13", BarcodeFormat.EAN_13.toString());
-          put("ean8", BarcodeFormat.EAN_8.toString());
-          put("qr", BarcodeFormat.QR_CODE.toString());
-          put("pdf417", BarcodeFormat.PDF_417.toString());
-          put("upc_e", BarcodeFormat.UPC_E.toString());
-          put("datamatrix", BarcodeFormat.DATA_MATRIX.toString());
-          put("code39", BarcodeFormat.CODE_39.toString());
-          put("code93", BarcodeFormat.CODE_93.toString());
-          put("interleaved2of5", BarcodeFormat.ITF.toString());
-          put("codabar", BarcodeFormat.CODABAR.toString());
-          put("code128", BarcodeFormat.CODE_128.toString());
-          put("maxicode", BarcodeFormat.MAXICODE.toString());
-          put("rss14", BarcodeFormat.RSS_14.toString());
-          put("rssexpanded", BarcodeFormat.RSS_EXPANDED.toString());
-          put("upc_a", BarcodeFormat.UPC_A.toString());
-          put("upc_ean", BarcodeFormat.UPC_EAN_EXTENSION.toString());
-        }
-      });
-
-  public CameraModule(ReactApplicationContext reactContext) {
-    super(reactContext);
-    mScopedContext = new ScopedContext(reactContext);
-  }
-
-  public ScopedContext getScopedContext() {
-    return mScopedContext;
-  }
-
-  @Override
-  public String getName() {
-    return "RNCameraModule";
-  }
-
-  @Nullable
-  @Override
-  public Map<String, Object> getConstants() {
-    return Collections.unmodifiableMap(new HashMap<String, Object>() {
-      {
-        put("Type", getTypeConstants());
-        put("FlashMode", getFlashModeConstants());
-        put("AutoFocus", getAutoFocusConstants());
-        put("WhiteBalance", getWhiteBalanceConstants());
-        put("VideoQuality", getVideoQualityConstants());
-        put("BarCodeType", getBarCodeConstants());
-        put("FaceDetection", Collections.unmodifiableMap(new HashMap<String, Object>() {
-          {
-            put("Mode", getFaceDetectionModeConstants());
-            put("Landmarks", getFaceDetectionLandmarksConstants());
-            put("Classifications", getFaceDetectionClassificationsConstants());
-          }
-
-          private Map<String, Object> getFaceDetectionModeConstants() {
-            return Collections.unmodifiableMap(new HashMap<String, Object>() {
-              {
-                put("fast", RNFaceDetector.FAST_MODE);
-                put("accurate", RNFaceDetector.ACCURATE_MODE);
-              }
-            });
-          }
-
-          private Map<String, Object> getFaceDetectionClassificationsConstants() {
-            return Collections.unmodifiableMap(new HashMap<String, Object>() {
-              {
-                put("all", RNFaceDetector.ALL_CLASSIFICATIONS);
-                put("none", RNFaceDetector.NO_CLASSIFICATIONS);
-              }
-            });
-          }
-
-          private Map<String, Object> getFaceDetectionLandmarksConstants() {
-            return Collections.unmodifiableMap(new HashMap<String, Object>() {
-              {
-                put("all", RNFaceDetector.ALL_LANDMARKS);
-                put("none", RNFaceDetector.NO_LANDMARKS);
-              }
-            });
-          }
-        }));
-        put("GoogleVisionBarcodeDetection", Collections.unmodifiableMap(new HashMap<String, Object>() {
-          {
-            put("BarcodeType", BarcodeFormatUtils.REVERSE_FORMATS);
-            put("BarcodeMode", getGoogleVisionBarcodeModeConstants());
-          }
-        }));
-        put("Orientation", Collections.unmodifiableMap(new HashMap<String, Object>() {
-            {
-              put("auto", Constants.ORIENTATION_AUTO);
-              put("portrait", Constants.ORIENTATION_UP);
-              put("portraitUpsideDown", Constants.ORIENTATION_DOWN);
-              put("landscapeLeft", Constants.ORIENTATION_LEFT);
-              put("landscapeRight", Constants.ORIENTATION_RIGHT);
-            }
-        }));
-      }
-
-      private Map<String, Object> getTypeConstants() {
-        return Collections.unmodifiableMap(new HashMap<String, Object>() {
-          {
-            put("front", Constants.FACING_FRONT);
-            put("back", Constants.FACING_BACK);
-          }
-        });
-      }
-
-      private Map<String, Object> getFlashModeConstants() {
-        return Collections.unmodifiableMap(new HashMap<String, Object>() {
-          {
-            put("off", Constants.FLASH_OFF);
-            put("on", Constants.FLASH_ON);
-            put("auto", Constants.FLASH_AUTO);
-            put("torch", Constants.FLASH_TORCH);
-          }
-        });
-      }
-
-      private Map<String, Object> getAutoFocusConstants() {
-        return Collections.unmodifiableMap(new HashMap<String, Object>() {
-          {
-            put("on", true);
-            put("off", false);
-          }
-        });
-      }
-
-      private Map<String, Object> getWhiteBalanceConstants() {
-        return Collections.unmodifiableMap(new HashMap<String, Object>() {
-          {
-            put("auto", Constants.WB_AUTO);
-            put("cloudy", Constants.WB_CLOUDY);
-            put("sunny", Constants.WB_SUNNY);
-            put("shadow", Constants.WB_SHADOW);
-            put("fluorescent", Constants.WB_FLUORESCENT);
-            put("incandescent", Constants.WB_INCANDESCENT);
-          }
-        });
-      }
-
-      private Map<String, Object> getVideoQualityConstants() {
-        return Collections.unmodifiableMap(new HashMap<String, Object>() {
-          {
-            put("2160p", VIDEO_2160P);
-            put("1080p", VIDEO_1080P);
-            put("720p", VIDEO_720P);
-            put("480p", VIDEO_480P);
-            put("4:3", VIDEO_4x3);
-          }
-        });
-      }
-
-      private Map<String, Object> getGoogleVisionBarcodeModeConstants() {
-        return Collections.unmodifiableMap(new HashMap<String, Object>() {
-          {
-            put("NORMAL", GOOGLE_VISION_BARCODE_MODE_NORMAL);
-            put("ALTERNATE", GOOGLE_VISION_BARCODE_MODE_ALTERNATE);
-            put("INVERTED", GOOGLE_VISION_BARCODE_MODE_INVERTED);
-          }
-        });
-      }
-
-      private Map<String, Object> getBarCodeConstants() {
-        return VALID_BARCODE_TYPES;
-      }
-    });
-  }
-
-    @ReactMethod
-    public void pausePreview(final int viewTag) {
-        final ReactApplicationContext context = getReactApplicationContext();
-        UIManagerModule uiManager = context.getNativeModule(UIManagerModule.class);
-        uiManager.addUIBlock(new UIBlock() {
-            @Override
-            public void execute(NativeViewHierarchyManager nativeViewHierarchyManager) {
-                final RNCameraView cameraView;
-
-                try {
-                    cameraView = (RNCameraView) nativeViewHierarchyManager.resolveView(viewTag);
-                    if (cameraView.isCameraOpened()) {
-                        cameraView.pausePreview();
-                    }
-                } catch (Exception e) {
-                    e.printStackTrace();
-                }
-            }
-        });
-    }
-
-    @ReactMethod
-    public void resumePreview(final int viewTag) {
-        final ReactApplicationContext context = getReactApplicationContext();
-        UIManagerModule uiManager = context.getNativeModule(UIManagerModule.class);
-        uiManager.addUIBlock(new UIBlock() {
-            @Override
-            public void execute(NativeViewHierarchyManager nativeViewHierarchyManager) {
-                final RNCameraView cameraView;
-
-                try {
-                    cameraView = (RNCameraView) nativeViewHierarchyManager.resolveView(viewTag);
-                    if (cameraView.isCameraOpened()) {
-                        cameraView.resumePreview();
-                    }
-                } catch (Exception e) {
-                    e.printStackTrace();
-                }
-            }
-        });
-    }
-
-  @ReactMethod
-  public void takePicture(final ReadableMap options, final int viewTag, final Promise promise) {
-    final ReactApplicationContext context = getReactApplicationContext();
-    final File cacheDirectory = mScopedContext.getCacheDirectory();
-    UIManagerModule uiManager = context.getNativeModule(UIManagerModule.class);
-    uiManager.addUIBlock(new UIBlock() {
-      @Override
-      public void execute(NativeViewHierarchyManager nativeViewHierarchyManager) {
-          RNCameraView cameraView = (RNCameraView) nativeViewHierarchyManager.resolveView(viewTag);
-          try {
-              if (cameraView.isCameraOpened()) {
-                cameraView.takePicture(options, promise, cacheDirectory);
-              } else {
-                promise.reject("E_CAMERA_UNAVAILABLE", "Camera is not running");
-              }
-          }
-          catch (Exception e) {
-            promise.reject("E_TAKE_PICTURE_FAILED", e.getMessage());
-          }
-      }
-    });
-  }
-
-  @ReactMethod
-  public void record(final ReadableMap options, final int viewTag, final Promise promise) {
-      final ReactApplicationContext context = getReactApplicationContext();
-      final File cacheDirectory = mScopedContext.getCacheDirectory();
-      UIManagerModule uiManager = context.getNativeModule(UIManagerModule.class);
-
-      uiManager.addUIBlock(new UIBlock() {
-          @Override
-          public void execute(NativeViewHierarchyManager nativeViewHierarchyManager) {
-              final RNCameraView cameraView;
-
-              try {
-                  cameraView = (RNCameraView) nativeViewHierarchyManager.resolveView(viewTag);
-                  if (cameraView.isCameraOpened()) {
-                      cameraView.record(options, promise, cacheDirectory);
-                  } else {
-                      promise.reject("E_CAMERA_UNAVAILABLE", "Camera is not running");
-                  }
-              } catch (Exception e) {
-                  promise.reject("E_CAPTURE_FAILED", e.getMessage());
-              }
-          }
-      });
-  }
-
-  @ReactMethod
-  public void stopRecording(final int viewTag) {
-      final ReactApplicationContext context = getReactApplicationContext();
-      UIManagerModule uiManager = context.getNativeModule(UIManagerModule.class);
-      uiManager.addUIBlock(new UIBlock() {
-          @Override
-          public void execute(NativeViewHierarchyManager nativeViewHierarchyManager) {
-              final RNCameraView cameraView;
-
-              try {
-                  cameraView = (RNCameraView) nativeViewHierarchyManager.resolveView(viewTag);
-                  if (cameraView.isCameraOpened()) {
-                      cameraView.stopRecording();
-                  }
-              } catch (Exception e) {
-                  e.printStackTrace();
-              }
-          }
-      });
-  }
-
-  @ReactMethod
-  public void pauseRecording(final int viewTag) {
-    final ReactApplicationContext context = getReactApplicationContext();
-    UIManagerModule uiManager = context.getNativeModule(UIManagerModule.class);
-    uiManager.addUIBlock(new UIBlock() {
-      @Override
-      public void execute(NativeViewHierarchyManager nativeViewHierarchyManager) {
-          final RNCameraView cameraView;
-
-          try {
-              cameraView = (RNCameraView) nativeViewHierarchyManager.resolveView(viewTag);
-              if (cameraView.isCameraOpened()) {
-                  cameraView.pauseRecording();
-              }
-          } catch (Exception e) {
-              e.printStackTrace();
-          }
-      }
-    });
-  }
-
-  @ReactMethod
-  public void resumeRecording(final int viewTag) {
-    final ReactApplicationContext context = getReactApplicationContext();
-    UIManagerModule uiManager = context.getNativeModule(UIManagerModule.class);
-    uiManager.addUIBlock(new UIBlock() {
-      @Override
-      public void execute(NativeViewHierarchyManager nativeViewHierarchyManager) {
-          final RNCameraView cameraView;
-
-          try {
-              cameraView = (RNCameraView) nativeViewHierarchyManager.resolveView(viewTag);
-              if (cameraView.isCameraOpened()) {
-                  cameraView.resumeRecording();
-              }
-          } catch (Exception e) {
-              e.printStackTrace();
-          }
-      }
-    });
-  }
-
-  @ReactMethod
-  public void getSupportedRatios(final int viewTag, final Promise promise) {
-      final ReactApplicationContext context = getReactApplicationContext();
-      UIManagerModule uiManager = context.getNativeModule(UIManagerModule.class);
-      uiManager.addUIBlock(new UIBlock() {
-          @Override
-          public void execute(NativeViewHierarchyManager nativeViewHierarchyManager) {
-              final RNCameraView cameraView;
-              try {
-                  cameraView = (RNCameraView) nativeViewHierarchyManager.resolveView(viewTag);
-                  WritableArray result = Arguments.createArray();
-                  if (cameraView.isCameraOpened()) {
-                      Set<AspectRatio> ratios = cameraView.getSupportedAspectRatios();
-                      for (AspectRatio ratio : ratios) {
-                          result.pushString(ratio.toString());
-                      }
-                      promise.resolve(result);
-                  } else {
-                      promise.reject("E_CAMERA_UNAVAILABLE", "Camera is not running");
-                  }
-              } catch (Exception e) {
-                  e.printStackTrace();
-              }
-          }
-      });
-  }
-
-  @ReactMethod
-  public void getCameraIds(final int viewTag, final Promise promise) {
-      final ReactApplicationContext context = getReactApplicationContext();
-      UIManagerModule uiManager = context.getNativeModule(UIManagerModule.class);
-      uiManager.addUIBlock(new UIBlock() {
-          @Override
-          public void execute(NativeViewHierarchyManager nativeViewHierarchyManager) {
-              final RNCameraView cameraView;
-              try {
-                  cameraView = (RNCameraView) nativeViewHierarchyManager.resolveView(viewTag);
-                  WritableArray result = Arguments.createArray();
-                  List<Properties> ids = cameraView.getCameraIds();
-                  for (Properties p : ids) {
-                      WritableMap m = new WritableNativeMap();
-                      m.putString("id", p.getProperty("id"));
-                      m.putInt("type", Integer.valueOf(p.getProperty("type")));
-                      result.pushMap(m);
-                  }
-                  promise.resolve(result);
-              } catch (Exception e) {
-                  e.printStackTrace();
-                  promise.reject("E_CAMERA_FAILED", e.getMessage());
-              }
-          }
-      });
-  }
-
-  @ReactMethod
-  public void getAvailablePictureSizes(final String ratio, final int viewTag, final Promise promise) {
-      final ReactApplicationContext context = getReactApplicationContext();
-      UIManagerModule uiManager = context.getNativeModule(UIManagerModule.class);
-      uiManager.addUIBlock(new UIBlock() {
-          @Override
-          public void execute(NativeViewHierarchyManager nativeViewHierarchyManager) {
-              final RNCameraView cameraView;
-
-              try {
-                  cameraView = (RNCameraView) nativeViewHierarchyManager.resolveView(viewTag);
-                  WritableArray result = Arguments.createArray();
-                  if (cameraView.isCameraOpened()) {
-                      SortedSet<Size> sizes = cameraView.getAvailablePictureSizes(AspectRatio.parse(ratio));
-                      for (Size size : sizes) {
-                          result.pushString(size.toString());
-                      }
-                      promise.resolve(result);
-                  } else {
-                      promise.reject("E_CAMERA_UNAVAILABLE", "Camera is not running");
-                  }
-              } catch (Exception e) {
-                  promise.reject("E_CAMERA_BAD_VIEWTAG", "getAvailablePictureSizesAsync: Expected a Camera component");
-              }
-          }
-      });
-  }
-
-  @ReactMethod
-  public void checkIfRecordAudioPermissionsAreDefined(final Promise promise) {
-      try {
-          PackageInfo info = getCurrentActivity().getPackageManager().getPackageInfo(getReactApplicationContext().getPackageName(), PackageManager.GET_PERMISSIONS);
-          if (info.requestedPermissions != null) {
-              for (String p : info.requestedPermissions) {
-                  if (p.equals(Manifest.permission.RECORD_AUDIO)) {
-                      promise.resolve(true);
-                      return;
-                  }
-              }
-          }
-      } catch (Exception e) {
-          e.printStackTrace();
-      }
-      promise.resolve(false);
-  }
-
-  @ReactMethod
-  public void getSupportedPreviewFpsRange(final int viewTag, final Promise promise) {
-      final ReactApplicationContext context = getReactApplicationContext();
-      UIManagerModule uiManager = context.getNativeModule(UIManagerModule.class);
-      uiManager.addUIBlock(new UIBlock() {
-          @Override
-          public void execute(NativeViewHierarchyManager nativeViewHierarchyManager) {
-              final RNCameraView cameraView;
-
-              try {
-                  cameraView = (RNCameraView) nativeViewHierarchyManager.resolveView(viewTag);
-                  WritableArray result = Arguments.createArray();
-                  ArrayList<int[]> ranges = cameraView.getSupportedPreviewFpsRange();
-                  for (int[] range : ranges) {
-                      WritableMap m = new WritableNativeMap();
-                      m.putInt("MINIMUM_FPS", range[0]);
-                      m.putInt("MAXIMUM_FPS", range[1]);
-                      result.pushMap(m);
-                  }
-                  promise.resolve(result);
-              } catch (Exception e) {
-                  e.printStackTrace();
-              }
-          }
-      });
-  }
-
-  @ReactMethod
-  public void hasTorch(final Promise promise) {
-      promise.resolve(getReactApplicationContext().getPackageManager().hasSystemFeature(PackageManager.FEATURE_CAMERA_FLASH));
-  }
-
-  // Helper method to check for corrupted videos on Android
-  @ReactMethod
-  public void checkIfVideoIsValid(final String path, final Promise promise) {
-
-    // run in a background thread in order to
-    // not block the UI
-    new GuardedAsyncTask<Void, Void>(getReactApplicationContext()) {
-      @Override
-      protected void doInBackgroundGuarded(Void... params) {
-        MediaMetadataRetriever retriever = new MediaMetadataRetriever();
-
-        try{
-          try {
-              retriever.setDataSource(path);
-          }
-          catch (Exception e){
-              e.printStackTrace();
-
-              // if we failed to load the source, also return true
-              // as this may cause false positives.
-              promise.resolve(true);
-              return;
-          }
-
-          // extract a few values since different devices may only report
-          // certain metadata
-          String hasVideo = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_HAS_VIDEO);
-          String mimeType = retriever.extractMetadata(MediaMetadataRetriever.METADATA_KEY_MIMETYPE);
-
-          // if we were unable to extract metadata, also return true
-          // since we will otherwise get false positives.
-          //promise.resolve(hasVideo == null || "yes".equals(hasVideo));
-          promise.resolve(hasVideo != null && ("yes".equals(hasVideo) || "true".equals(hasVideo) ||
-            mimeType != null && mimeType.contains("video")));
-        }
-        finally{
-          // this many fail or may not be available in API < 29
-          try{
-            retriever.release();
-          }
-          catch(Throwable e){}
-        }
-      }
-    }.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/CameraViewManager.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/CameraViewManager.java
deleted file mode 100644
index 9ffd467..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/CameraViewManager.java
+++ /dev/null
@@ -1,246 +0,0 @@
-package org.reactnative.camera;
-
-import androidx.annotation.Nullable;
-import com.facebook.react.bridge.ReadableArray;
-import com.facebook.react.bridge.ReadableMap;
-import com.facebook.react.common.MapBuilder;
-import com.facebook.react.uimanager.ThemedReactContext;
-import com.facebook.react.uimanager.ViewGroupManager;
-import com.facebook.react.uimanager.annotations.ReactProp;
-import com.google.android.cameraview.AspectRatio;
-import com.google.android.cameraview.Size;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-public class CameraViewManager extends ViewGroupManager<RNCameraView> {
-  public enum Events {
-    EVENT_CAMERA_READY("onCameraReady"),
-    EVENT_ON_MOUNT_ERROR("onMountError"),
-    EVENT_ON_BAR_CODE_READ("onBarCodeRead"),
-    EVENT_ON_FACES_DETECTED("onFacesDetected"),
-    EVENT_ON_BARCODES_DETECTED("onGoogleVisionBarcodesDetected"),
-    EVENT_ON_FACE_DETECTION_ERROR("onFaceDetectionError"),
-    EVENT_ON_BARCODE_DETECTION_ERROR("onGoogleVisionBarcodeDetectionError"),
-    EVENT_ON_TEXT_RECOGNIZED("onTextRecognized"),
-    EVENT_ON_PICTURE_TAKEN("onPictureTaken"),
-    EVENT_ON_PICTURE_SAVED("onPictureSaved"),
-    EVENT_ON_RECORDING_START("onRecordingStart"),
-    EVENT_ON_RECORDING_END("onRecordingEnd"),
-    EVENT_ON_TOUCH("onTouch");
-
-
-    private final String mName;
-
-    Events(final String name) {
-      mName = name;
-    }
-
-    @Override
-    public String toString() {
-      return mName;
-    }
-  }
-
-  private static final String REACT_CLASS = "RNCamera";
-
-  @Override
-  public void onDropViewInstance(RNCameraView view) {
-    view.onHostDestroy();
-    super.onDropViewInstance(view);
-  }
-
-
-  @Override
-  public String getName() {
-    return REACT_CLASS;
-  }
-
-  @Override
-  protected RNCameraView createViewInstance(ThemedReactContext themedReactContext) {
-    return new RNCameraView(themedReactContext);
-  }
-
-  @Override
-  @Nullable
-  public Map<String, Object> getExportedCustomDirectEventTypeConstants() {
-    MapBuilder.Builder<String, Object> builder = MapBuilder.builder();
-    for (Events event : Events.values()) {
-      builder.put(event.toString(), MapBuilder.of("registrationName", event.toString()));
-    }
-    return builder.build();
-  }
-
-  @ReactProp(name = "type")
-  public void setType(RNCameraView view, int type) {
-    view.setFacing(type);
-  }
-
-  @ReactProp(name = "cameraId")
-  public void setCameraId(RNCameraView view, String id) {
-    view.setCameraId(id);
-  }
-
-  @ReactProp(name = "ratio")
-  public void setRatio(RNCameraView view, String ratio) {
-    view.setAspectRatio(AspectRatio.parse(ratio));
-  }
-
-  @ReactProp(name = "flashMode")
-  public void setFlashMode(RNCameraView view, int torchMode) {
-    view.setFlash(torchMode);
-  }
-
-  @ReactProp(name = "exposure")
-  public void setExposureCompensation(RNCameraView view, float exposure){
-    view.setExposureCompensation(exposure);
-  }
-
-  @ReactProp(name = "autoFocus")
-  public void setAutoFocus(RNCameraView view, boolean autoFocus) {
-    view.setAutoFocus(autoFocus);
-  }
-
-  @ReactProp(name = "focusDepth")
-  public void setFocusDepth(RNCameraView view, float depth) {
-    view.setFocusDepth(depth);
-  }
-
-  @ReactProp(name = "autoFocusPointOfInterest")
-  public void setAutoFocusPointOfInterest(RNCameraView view, ReadableMap coordinates) {
-    if(coordinates != null){
-      float x = (float) coordinates.getDouble("x");
-      float y = (float) coordinates.getDouble("y");
-      view.setAutoFocusPointOfInterest(x, y);
-    }
-  }
-
-  @ReactProp(name = "zoom")
-  public void setZoom(RNCameraView view, float zoom) {
-    view.setZoom(zoom);
-  }
-
-  @ReactProp(name = "useNativeZoom")
-  public void setUseNativeZoom(RNCameraView view, boolean useNativeZoom) {
-    view.setUseNativeZoom(useNativeZoom);
-  }
-  @ReactProp(name = "whiteBalance")
-  public void setWhiteBalance(RNCameraView view, int whiteBalance) {
-    view.setWhiteBalance(whiteBalance);
-  }
-
-  @ReactProp(name = "pictureSize")
-  public void setPictureSize(RNCameraView view, String size) {
-    view.setPictureSize(size.equals("None") ? null : Size.parse(size));
-  }
-
-  @ReactProp(name = "playSoundOnCapture")
-  public void setPlaySoundOnCapture(RNCameraView view, boolean playSoundOnCapture) {
-    view.setPlaySoundOnCapture(playSoundOnCapture);
-  }
-
-  @ReactProp(name = "playSoundOnRecord")
-  public void setPlaySoundOnRecord(RNCameraView view, boolean playSoundOnRecord) {
-    view.setPlaySoundOnRecord(playSoundOnRecord);
-  }
-
-  @ReactProp(name = "barCodeTypes")
-  public void setBarCodeTypes(RNCameraView view, ReadableArray barCodeTypes) {
-    if (barCodeTypes == null) {
-      return;
-    }
-    List<String> result = new ArrayList<>(barCodeTypes.size());
-    for (int i = 0; i < barCodeTypes.size(); i++) {
-      result.add(barCodeTypes.getString(i));
-    }
-    view.setBarCodeTypes(result);
-  }
-
-  @ReactProp(name = "detectedImageInEvent")
-  public void setDetectedImageInEvent(RNCameraView view, boolean detectedImageInEvent) {
-    view.setDetectedImageInEvent(detectedImageInEvent);
-  }
-
-  @ReactProp(name = "barCodeScannerEnabled")
-  public void setBarCodeScanning(RNCameraView view, boolean barCodeScannerEnabled) {
-    view.setShouldScanBarCodes(barCodeScannerEnabled);
-  }
-
-  @ReactProp(name = "useCamera2Api")
-  public void setUseCamera2Api(RNCameraView view, boolean useCamera2Api) {
-    view.setUsingCamera2Api(useCamera2Api);
-  }
-
-  @ReactProp(name = "touchDetectorEnabled")
-  public void setTouchDetectorEnabled(RNCameraView view, boolean touchDetectorEnabled) {
-    view.setShouldDetectTouches(touchDetectorEnabled);
-  }
-
-  @ReactProp(name = "faceDetectorEnabled")
-  public void setFaceDetecting(RNCameraView view, boolean faceDetectorEnabled) {
-    view.setShouldDetectFaces(faceDetectorEnabled);
-  }
-
-  @ReactProp(name = "faceDetectionMode")
-  public void setFaceDetectionMode(RNCameraView view, int mode) {
-    view.setFaceDetectionMode(mode);
-  }
-
-  @ReactProp(name = "faceDetectionLandmarks")
-  public void setFaceDetectionLandmarks(RNCameraView view, int landmarks) {
-    view.setFaceDetectionLandmarks(landmarks);
-  }
-
-  @ReactProp(name = "faceDetectionClassifications")
-  public void setFaceDetectionClassifications(RNCameraView view, int classifications) {
-    view.setFaceDetectionClassifications(classifications);
-  }
-
-  @ReactProp(name = "trackingEnabled")
-  public void setTracking(RNCameraView view, boolean trackingEnabled) {
-    view.setTracking(trackingEnabled);
-  }
-
-  @ReactProp(name = "googleVisionBarcodeDetectorEnabled")
-  public void setGoogleVisionBarcodeDetecting(RNCameraView view, boolean googleBarcodeDetectorEnabled) {
-    view.setShouldGoogleDetectBarcodes(googleBarcodeDetectorEnabled);
-  }
-
-  @ReactProp(name = "googleVisionBarcodeType")
-  public void setGoogleVisionBarcodeType(RNCameraView view, int barcodeType) {
-    view.setGoogleVisionBarcodeType(barcodeType);
-  }
-
-  @ReactProp(name = "googleVisionBarcodeMode")
-  public void setGoogleVisionBarcodeMode(RNCameraView view, int barcodeMode) {
-    view.setGoogleVisionBarcodeMode(barcodeMode);
-  }
-
-  @ReactProp(name = "textRecognizerEnabled")
-  public void setTextRecognizing(RNCameraView view, boolean textRecognizerEnabled) {
-    view.setShouldRecognizeText(textRecognizerEnabled);
-  }
-
-  /**---limit scan area addition---**/
-  @ReactProp(name = "rectOfInterest")
-  public void setRectOfInterest(RNCameraView view, ReadableMap coordinates) {
-    if(coordinates != null){
-      float x = (float) coordinates.getDouble("x");
-      float y = (float) coordinates.getDouble("y");
-      float width = (float) coordinates.getDouble("width");
-      float height = (float) coordinates.getDouble("height");
-      view.setRectOfInterest(x, y, width, height);
-    }
-  }
-
-  @ReactProp(name = "cameraViewDimensions")
-  public void setCameraViewDimensions(RNCameraView view, ReadableMap dimensions) {
-    if(dimensions != null){
-      int cameraViewWidth = (int) dimensions.getDouble("width");
-      int cameraViewHeight = (int) dimensions.getDouble("height");
-      view.setCameraViewDimensions(cameraViewWidth, cameraViewHeight);
-    }
-  }
-  /**---limit scan area addition---**/
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/Constants.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/Constants.java
deleted file mode 100644
index 324bc7e..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/Constants.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2016 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.reactnative.camera;
-
-import com.google.android.cameraview.AspectRatio;
-
-public interface Constants {
-
-  AspectRatio DEFAULT_ASPECT_RATIO = AspectRatio.of(4, 3);
-
-  int FACING_BACK = 0;
-  int FACING_FRONT = 1;
-
-  int FLASH_OFF = 0;
-  int FLASH_ON = 1;
-  int FLASH_TORCH = 2;
-  int FLASH_AUTO = 3;
-  int FLASH_RED_EYE = 4;
-
-  int LANDSCAPE_90 = 90;
-  int LANDSCAPE_270 = 270;
-
-  int WB_AUTO = 0;
-  int WB_CLOUDY = 1;
-  int WB_SUNNY = 2;
-  int WB_SHADOW = 3;
-  int WB_FLUORESCENT = 4;
-  int WB_INCANDESCENT = 5;
-
-  int ORIENTATION_AUTO = 0;
-  int ORIENTATION_UP = 1;
-  int ORIENTATION_DOWN = 2;
-  int ORIENTATION_LEFT = 3;
-  int ORIENTATION_RIGHT = 4;
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/RNCameraPackage.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/RNCameraPackage.java
deleted file mode 100644
index a72a71b..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/RNCameraPackage.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package org.reactnative.camera;
-
-import com.facebook.react.ReactPackage;
-import com.facebook.react.bridge.JavaScriptModule;
-import com.facebook.react.bridge.NativeModule;
-import com.facebook.react.bridge.ReactApplicationContext;
-import com.facebook.react.uimanager.ViewManager;
-import com.lwansbrough.RCTCamera.RCTCameraModule;
-import com.lwansbrough.RCTCamera.RCTCameraViewManager;
-
-import org.reactnative.facedetector.FaceDetectorModule;
-
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-
-/**
- * Created by jgfidelis on 02/02/18.
- */
-
-public class RNCameraPackage implements ReactPackage {
-    @Override
-    public List<NativeModule> createNativeModules(ReactApplicationContext reactApplicationContext) {
-        return Arrays.<NativeModule>asList(
-                new RCTCameraModule(reactApplicationContext),
-                new CameraModule(reactApplicationContext),
-                new FaceDetectorModule(reactApplicationContext)
-        );
-    }
-
-    // Deprecated in RN 0.47
-    public List<Class<? extends JavaScriptModule>> createJSModules() {
-        return Collections.emptyList();
-    }
-
-    @Override
-    public List<ViewManager> createViewManagers(ReactApplicationContext reactApplicationContext) {
-        return Arrays.<ViewManager>asList(
-                new RCTCameraViewManager(),
-                new CameraViewManager()
-        );
-    }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/RNCameraView.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/RNCameraView.java
deleted file mode 100644
index 16cd1ba..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/RNCameraView.java
+++ /dev/null
@@ -1,710 +0,0 @@
-package org.reactnative.camera;
-
-import android.Manifest;
-import android.annotation.SuppressLint;
-import android.content.pm.PackageManager;
-import android.content.res.Configuration;
-import android.content.res.Resources;
-import android.graphics.Color;
-import android.graphics.ImageFormat;
-import android.graphics.Rect;
-import android.graphics.YuvImage;
-import android.media.CamcorderProfile;
-import android.os.Build;
-import androidx.core.content.ContextCompat;
-
-import android.util.DisplayMetrics;
-import android.view.GestureDetector;
-import android.view.MotionEvent;
-import android.view.ScaleGestureDetector;
-import android.view.View;
-import android.os.AsyncTask;
-import com.facebook.react.bridge.*;
-import com.facebook.react.uimanager.ThemedReactContext;
-import com.google.android.cameraview.CameraView;
-import com.google.zxing.BarcodeFormat;
-import com.google.zxing.DecodeHintType;
-import com.google.zxing.MultiFormatReader;
-import com.google.zxing.Result;
-import org.reactnative.barcodedetector.RNBarcodeDetector;
-import org.reactnative.camera.tasks.*;
-import org.reactnative.camera.utils.RNFileUtils;
-import org.reactnative.facedetector.RNFaceDetector;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.IOException;
-import java.util.*;
-import java.util.concurrent.ConcurrentHashMap;
-import java.util.concurrent.ConcurrentLinkedQueue;
-
-public class RNCameraView extends CameraView implements LifecycleEventListener, BarCodeScannerAsyncTaskDelegate, FaceDetectorAsyncTaskDelegate,
-    BarcodeDetectorAsyncTaskDelegate, TextRecognizerAsyncTaskDelegate, PictureSavedDelegate {
-  private ThemedReactContext mThemedReactContext;
-  private Queue<Promise> mPictureTakenPromises = new ConcurrentLinkedQueue<>();
-  private Map<Promise, ReadableMap> mPictureTakenOptions = new ConcurrentHashMap<>();
-  private Map<Promise, File> mPictureTakenDirectories = new ConcurrentHashMap<>();
-  private Promise mVideoRecordedPromise;
-  private List<String> mBarCodeTypes = null;
-  private boolean mDetectedImageInEvent = false;
-
-  private ScaleGestureDetector mScaleGestureDetector;
-  private GestureDetector mGestureDetector;
-
-
-  private boolean mIsPaused = false;
-  private boolean mIsNew = true;
-  private boolean invertImageData = false;
-  private Boolean mIsRecording = false;
-  private Boolean mIsRecordingInterrupted = false;
-  private boolean mUseNativeZoom=false;
-
-  // Concurrency lock for scanners to avoid flooding the runtime
-  public volatile boolean barCodeScannerTaskLock = false;
-  public volatile boolean faceDetectorTaskLock = false;
-  public volatile boolean googleBarcodeDetectorTaskLock = false;
-  public volatile boolean textRecognizerTaskLock = false;
-
-  // Scanning-related properties
-  private MultiFormatReader mMultiFormatReader;
-  private RNFaceDetector mFaceDetector;
-  private RNBarcodeDetector mGoogleBarcodeDetector;
-  private boolean mShouldDetectFaces = false;
-  private boolean mShouldGoogleDetectBarcodes = false;
-  private boolean mShouldScanBarCodes = false;
-  private boolean mShouldRecognizeText = false;
-  private boolean mShouldDetectTouches = false;
-  private int mFaceDetectorMode = RNFaceDetector.FAST_MODE;
-  private int mFaceDetectionLandmarks = RNFaceDetector.NO_LANDMARKS;
-  private int mFaceDetectionClassifications = RNFaceDetector.NO_CLASSIFICATIONS;
-  private int mGoogleVisionBarCodeType = RNBarcodeDetector.ALL_FORMATS;
-  private int mGoogleVisionBarCodeMode = RNBarcodeDetector.NORMAL_MODE;
-  private boolean mTrackingEnabled = true;
-  private int mPaddingX;
-  private int mPaddingY;
-
-  // Limit Android Scan Area
-  private boolean mLimitScanArea = false;
-  private float mScanAreaX = 0.0f;
-  private float mScanAreaY = 0.0f;
-  private float mScanAreaWidth = 0.0f;
-  private float mScanAreaHeight = 0.0f;
-  private int mCameraViewWidth = 0;
-  private int mCameraViewHeight = 0;
-
-  public RNCameraView(ThemedReactContext themedReactContext) {
-    super(themedReactContext, true);
-    mThemedReactContext = themedReactContext;
-    themedReactContext.addLifecycleEventListener(this);
-
-    addCallback(new Callback() {
-      @Override
-      public void onCameraOpened(CameraView cameraView) {
-        RNCameraViewHelper.emitCameraReadyEvent(cameraView);
-      }
-
-      @Override
-      public void onMountError(CameraView cameraView) {
-        RNCameraViewHelper.emitMountErrorEvent(cameraView, "Camera view threw an error - component could not be rendered.");
-      }
-
-      @Override
-      public void onPictureTaken(CameraView cameraView, final byte[] data, int deviceOrientation, int softwareRotation) {
-        Promise promise = mPictureTakenPromises.poll();
-        ReadableMap options = mPictureTakenOptions.remove(promise);
-        if (options.hasKey("fastMode") && options.getBoolean("fastMode")) {
-            promise.resolve(null);
-        }
-        final File cacheDirectory = mPictureTakenDirectories.remove(promise);
-        if(Build.VERSION.SDK_INT >= 11/*HONEYCOMB*/) {
-          new ResolveTakenPictureAsyncTask(data, promise, options, cacheDirectory, deviceOrientation, softwareRotation, RNCameraView.this)
-                  .executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
-        } else {
-          new ResolveTakenPictureAsyncTask(data, promise, options, cacheDirectory, deviceOrientation, softwareRotation, RNCameraView.this)
-                  .execute();
-        }
-        RNCameraViewHelper.emitPictureTakenEvent(cameraView);
-      }
-
-      @Override
-      public void onRecordingStart(CameraView cameraView, String path, int videoOrientation, int deviceOrientation) {
-        WritableMap result = Arguments.createMap();
-        result.putInt("videoOrientation", videoOrientation);
-        result.putInt("deviceOrientation", deviceOrientation);
-        result.putString("uri", RNFileUtils.uriFromFile(new File(path)).toString());
-        RNCameraViewHelper.emitRecordingStartEvent(cameraView, result);
-      }
-
-      @Override
-      public void onRecordingEnd(CameraView cameraView) {
-        RNCameraViewHelper.emitRecordingEndEvent(cameraView);
-      }
-
-      @Override
-      public void onVideoRecorded(CameraView cameraView, String path, int videoOrientation, int deviceOrientation) {
-        if (mVideoRecordedPromise != null) {
-          if (path != null) {
-            WritableMap result = Arguments.createMap();
-            result.putBoolean("isRecordingInterrupted", mIsRecordingInterrupted);
-            result.putInt("videoOrientation", videoOrientation);
-            result.putInt("deviceOrientation", deviceOrientation);
-            result.putString("uri", RNFileUtils.uriFromFile(new File(path)).toString());
-            mVideoRecordedPromise.resolve(result);
-          } else {
-            mVideoRecordedPromise.reject("E_RECORDING", "Couldn't stop recording - there is none in progress");
-          }
-          mIsRecording = false;
-          mIsRecordingInterrupted = false;
-          mVideoRecordedPromise = null;
-        }
-      }
-
-      @Override
-      public void onFramePreview(CameraView cameraView, byte[] data, int width, int height, int rotation) {
-        int correctRotation = RNCameraViewHelper.getCorrectCameraRotation(rotation, getFacing(), getCameraOrientation());
-        boolean willCallBarCodeTask = mShouldScanBarCodes && !barCodeScannerTaskLock && cameraView instanceof BarCodeScannerAsyncTaskDelegate;
-        boolean willCallFaceTask = mShouldDetectFaces && !faceDetectorTaskLock && cameraView instanceof FaceDetectorAsyncTaskDelegate;
-        boolean willCallGoogleBarcodeTask = mShouldGoogleDetectBarcodes && !googleBarcodeDetectorTaskLock && cameraView instanceof BarcodeDetectorAsyncTaskDelegate;
-        boolean willCallTextTask = mShouldRecognizeText && !textRecognizerTaskLock && cameraView instanceof TextRecognizerAsyncTaskDelegate;
-        if (!willCallBarCodeTask && !willCallFaceTask && !willCallGoogleBarcodeTask && !willCallTextTask) {
-          return;
-        }
-
-        if (data.length < (1.5 * width * height)) {
-            return;
-        }
-
-        if (willCallBarCodeTask) {
-          barCodeScannerTaskLock = true;
-          BarCodeScannerAsyncTaskDelegate delegate = (BarCodeScannerAsyncTaskDelegate) cameraView;
-          new BarCodeScannerAsyncTask(delegate, mMultiFormatReader, data, width, height, mLimitScanArea, mScanAreaX, mScanAreaY, mScanAreaWidth, mScanAreaHeight, mCameraViewWidth, mCameraViewHeight, getAspectRatio().toFloat()).execute();
-        }
-
-        if (willCallFaceTask) {
-          faceDetectorTaskLock = true;
-          FaceDetectorAsyncTaskDelegate delegate = (FaceDetectorAsyncTaskDelegate) cameraView;
-          new FaceDetectorAsyncTask(delegate, mFaceDetector, data, width, height, correctRotation, getResources().getDisplayMetrics().density, getFacing(), getWidth(), getHeight(), mPaddingX, mPaddingY).execute();
-        }
-
-        if (willCallGoogleBarcodeTask) {
-          googleBarcodeDetectorTaskLock = true;
-          if (mGoogleVisionBarCodeMode == RNBarcodeDetector.NORMAL_MODE) {
-            invertImageData = false;
-          } else if (mGoogleVisionBarCodeMode == RNBarcodeDetector.ALTERNATE_MODE) {
-            invertImageData = !invertImageData;
-          } else if (mGoogleVisionBarCodeMode == RNBarcodeDetector.INVERTED_MODE) {
-            invertImageData = true;
-          }
-          if (invertImageData) {
-            for (int y = 0; y < data.length; y++) {
-              data[y] = (byte) ~data[y];
-            }
-          }
-          BarcodeDetectorAsyncTaskDelegate delegate = (BarcodeDetectorAsyncTaskDelegate) cameraView;
-          new BarcodeDetectorAsyncTask(delegate, mGoogleBarcodeDetector, data, width, height,
-                  correctRotation, getResources().getDisplayMetrics().density, getFacing(),
-                  getWidth(), getHeight(), mPaddingX, mPaddingY).execute();
-        }
-
-        if (willCallTextTask) {
-          textRecognizerTaskLock = true;
-          TextRecognizerAsyncTaskDelegate delegate = (TextRecognizerAsyncTaskDelegate) cameraView;
-          new TextRecognizerAsyncTask(delegate, mThemedReactContext, data, width, height, correctRotation, getResources().getDisplayMetrics().density, getFacing(), getWidth(), getHeight(), mPaddingX, mPaddingY).execute();
-        }
-      }
-    });
-  }
-
-  @Override
-  protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
-    View preview = getView();
-    if (null == preview) {
-      return;
-    }
-    float width = right - left;
-    float height = bottom - top;
-    float ratio = getAspectRatio().toFloat();
-    int orientation = getResources().getConfiguration().orientation;
-    int correctHeight;
-    int correctWidth;
-    this.setBackgroundColor(Color.BLACK);
-    if (orientation == android.content.res.Configuration.ORIENTATION_LANDSCAPE) {
-      if (ratio * height < width) {
-        correctHeight = (int) (width / ratio);
-        correctWidth = (int) width;
-      } else {
-        correctWidth = (int) (height * ratio);
-        correctHeight = (int) height;
-      }
-    } else {
-      if (ratio * width > height) {
-        correctHeight = (int) (width * ratio);
-        correctWidth = (int) width;
-      } else {
-        correctWidth = (int) (height / ratio);
-        correctHeight = (int) height;
-      }
-    }
-    int paddingX = (int) ((width - correctWidth) / 2);
-    int paddingY = (int) ((height - correctHeight) / 2);
-    mPaddingX = paddingX;
-    mPaddingY = paddingY;
-    preview.layout(paddingX, paddingY, correctWidth + paddingX, correctHeight + paddingY);
-  }
-
-  @SuppressLint("all")
-  @Override
-  public void requestLayout() {
-    // React handles this for us, so we don't need to call super.requestLayout();
-  }
-
-  public void setBarCodeTypes(List<String> barCodeTypes) {
-    mBarCodeTypes = barCodeTypes;
-    initBarcodeReader();
-  }
-
-  public void setDetectedImageInEvent(boolean detectedImageInEvent) {
-    this.mDetectedImageInEvent = detectedImageInEvent;
-  }
-
-  public void takePicture(final ReadableMap options, final Promise promise, final File cacheDirectory) {
-    mBgHandler.post(new Runnable() {
-      @Override
-      public void run() {
-        mPictureTakenPromises.add(promise);
-        mPictureTakenOptions.put(promise, options);
-        mPictureTakenDirectories.put(promise, cacheDirectory);
-
-        try {
-          RNCameraView.super.takePicture(options);
-        } catch (Exception e) {
-          mPictureTakenPromises.remove(promise);
-          mPictureTakenOptions.remove(promise);
-          mPictureTakenDirectories.remove(promise);
-
-          promise.reject("E_TAKE_PICTURE_FAILED", e.getMessage());
-        }
-      }
-    });
-  }
-
-  @Override
-  public void onPictureSaved(WritableMap response) {
-    RNCameraViewHelper.emitPictureSavedEvent(this, response);
-  }
-
-  public void record(final ReadableMap options, final Promise promise, final File cacheDirectory) {
-    mBgHandler.post(new Runnable() {
-      @Override
-      public void run() {
-        try {
-          String path = options.hasKey("path") ? options.getString("path") : RNFileUtils.getOutputFilePath(cacheDirectory, ".mp4");
-          int maxDuration = options.hasKey("maxDuration") ? options.getInt("maxDuration") : -1;
-          int maxFileSize = options.hasKey("maxFileSize") ? options.getInt("maxFileSize") : -1;
-          int fps = options.hasKey("fps") ? options.getInt("fps") : -1;
-
-          CamcorderProfile profile = CamcorderProfile.get(CamcorderProfile.QUALITY_HIGH);
-          if (options.hasKey("quality")) {
-            profile = RNCameraViewHelper.getCamcorderProfile(options.getInt("quality"));
-          }
-          if (options.hasKey("videoBitrate")) {
-            profile.videoBitRate = options.getInt("videoBitrate");
-          }
-
-          boolean recordAudio = true;
-          if (options.hasKey("mute")) {
-            recordAudio = !options.getBoolean("mute");
-          }
-
-          int orientation = Constants.ORIENTATION_AUTO;
-          if (options.hasKey("orientation")) {
-            orientation = options.getInt("orientation");
-          }
-
-          if (RNCameraView.super.record(path, maxDuration * 1000, maxFileSize, recordAudio, profile, orientation, fps)) {
-            mIsRecording = true;
-            mVideoRecordedPromise = promise;
-          } else {
-            promise.reject("E_RECORDING_FAILED", "Starting video recording failed. Another recording might be in progress.");
-          }
-        } catch (IOException e) {
-          promise.reject("E_RECORDING_FAILED", "Starting video recording failed - could not create video file.");
-        }
-      }
-    });
-  }
-
-  /**
-   * Initialize the barcode decoder.
-   * Supports all iOS codes except [code138, code39mod43, itf14]
-   * Additionally supports [codabar, code128, maxicode, rss14, rssexpanded, upc_a, upc_ean]
-   */
-  private void initBarcodeReader() {
-    mMultiFormatReader = new MultiFormatReader();
-    EnumMap<DecodeHintType, Object> hints = new EnumMap<>(DecodeHintType.class);
-    EnumSet<BarcodeFormat> decodeFormats = EnumSet.noneOf(BarcodeFormat.class);
-
-    if (mBarCodeTypes != null) {
-      for (String code : mBarCodeTypes) {
-        String formatString = (String) CameraModule.VALID_BARCODE_TYPES.get(code);
-        if (formatString != null) {
-          decodeFormats.add(BarcodeFormat.valueOf(formatString));
-        }
-      }
-    }
-
-    hints.put(DecodeHintType.POSSIBLE_FORMATS, decodeFormats);
-    mMultiFormatReader.setHints(hints);
-  }
-
-  public void setShouldScanBarCodes(boolean shouldScanBarCodes) {
-    if (shouldScanBarCodes && mMultiFormatReader == null) {
-      initBarcodeReader();
-    }
-    this.mShouldScanBarCodes = shouldScanBarCodes;
-    setScanning(mShouldDetectFaces || mShouldGoogleDetectBarcodes || mShouldScanBarCodes || mShouldRecognizeText);
-  }
-
-  public void onBarCodeRead(Result barCode, int width, int height, byte[] imageData) {
-    String barCodeType = barCode.getBarcodeFormat().toString();
-    if (!mShouldScanBarCodes || !mBarCodeTypes.contains(barCodeType)) {
-      return;
-    }
-
-    final byte[] compressedImage;
-    if (mDetectedImageInEvent) {
-      try {
-        // https://stackoverflow.com/a/32793908/122441
-        final YuvImage yuvImage = new YuvImage(imageData, ImageFormat.NV21, width, height, null);
-        final ByteArrayOutputStream imageStream = new ByteArrayOutputStream();
-        yuvImage.compressToJpeg(new Rect(0, 0, width, height), 100, imageStream);
-        compressedImage = imageStream.toByteArray();
-      } catch (Exception e) {
-        throw new RuntimeException(String.format("Error decoding imageData from NV21 format (%d bytes)", imageData.length), e);
-      }
-    } else {
-      compressedImage = null;
-    }
-
-    RNCameraViewHelper.emitBarCodeReadEvent(this, barCode, width, height, compressedImage);
-  }
-
-  public void onBarCodeScanningTaskCompleted() {
-    barCodeScannerTaskLock = false;
-    if(mMultiFormatReader != null) {
-      mMultiFormatReader.reset();
-    }
-  }
-
-  // Limit Scan Area
-  public void setRectOfInterest(float x, float y, float width, float height) {
-    this.mLimitScanArea = true;
-    this.mScanAreaX = x;
-    this.mScanAreaY = y;
-    this.mScanAreaWidth = width;
-    this.mScanAreaHeight = height;
-  }
-  public void setCameraViewDimensions(int width, int height) {
-    this.mCameraViewWidth = width;
-    this.mCameraViewHeight = height;
-  }
-
-
-  public void setShouldDetectTouches(boolean shouldDetectTouches) {
-    if(!mShouldDetectTouches && shouldDetectTouches){
-      mGestureDetector=new GestureDetector(mThemedReactContext,onGestureListener);
-    }else{
-      mGestureDetector=null;
-    }
-    this.mShouldDetectTouches = shouldDetectTouches;
-  }
-
-  public void setUseNativeZoom(boolean useNativeZoom){
-    if(!mUseNativeZoom && useNativeZoom){
-      mScaleGestureDetector = new ScaleGestureDetector(mThemedReactContext,onScaleGestureListener);
-    }else{
-      mScaleGestureDetector=null;
-    }
-    mUseNativeZoom=useNativeZoom;
-  }
-
-  @Override
-  public boolean onTouchEvent(MotionEvent event) {
-    if(mUseNativeZoom) {
-      mScaleGestureDetector.onTouchEvent(event);
-    }
-    if(mShouldDetectTouches){
-      mGestureDetector.onTouchEvent(event);
-    }
-    return true;
-  }
-
-  /**
-   * Initial setup of the face detector
-   */
-  private void setupFaceDetector() {
-    mFaceDetector = new RNFaceDetector(mThemedReactContext);
-    mFaceDetector.setMode(mFaceDetectorMode);
-    mFaceDetector.setLandmarkType(mFaceDetectionLandmarks);
-    mFaceDetector.setClassificationType(mFaceDetectionClassifications);
-    mFaceDetector.setTracking(mTrackingEnabled);
-  }
-
-  public void setFaceDetectionLandmarks(int landmarks) {
-    mFaceDetectionLandmarks = landmarks;
-    if (mFaceDetector != null) {
-      mFaceDetector.setLandmarkType(landmarks);
-    }
-  }
-
-  public void setFaceDetectionClassifications(int classifications) {
-    mFaceDetectionClassifications = classifications;
-    if (mFaceDetector != null) {
-      mFaceDetector.setClassificationType(classifications);
-    }
-  }
-
-  public void setFaceDetectionMode(int mode) {
-    mFaceDetectorMode = mode;
-    if (mFaceDetector != null) {
-      mFaceDetector.setMode(mode);
-    }
-  }
-
-  public void setTracking(boolean trackingEnabled) {
-    mTrackingEnabled = trackingEnabled;
-    if (mFaceDetector != null) {
-      mFaceDetector.setTracking(trackingEnabled);
-    }
-  }
-
-  public void setShouldDetectFaces(boolean shouldDetectFaces) {
-    if (shouldDetectFaces && mFaceDetector == null) {
-      setupFaceDetector();
-    }
-    this.mShouldDetectFaces = shouldDetectFaces;
-    setScanning(mShouldDetectFaces || mShouldGoogleDetectBarcodes || mShouldScanBarCodes || mShouldRecognizeText);
-  }
-
-  public void onFacesDetected(WritableArray data) {
-    if (!mShouldDetectFaces) {
-      return;
-    }
-
-    RNCameraViewHelper.emitFacesDetectedEvent(this, data);
-  }
-
-  public void onFaceDetectionError(RNFaceDetector faceDetector) {
-    if (!mShouldDetectFaces) {
-      return;
-    }
-
-    RNCameraViewHelper.emitFaceDetectionErrorEvent(this, faceDetector);
-  }
-
-  @Override
-  public void onFaceDetectingTaskCompleted() {
-    faceDetectorTaskLock = false;
-  }
-
-  /**
-   * Initial setup of the barcode detector
-   */
-  private void setupBarcodeDetector() {
-    mGoogleBarcodeDetector = new RNBarcodeDetector(mThemedReactContext);
-    mGoogleBarcodeDetector.setBarcodeType(mGoogleVisionBarCodeType);
-  }
-
-  public void setShouldGoogleDetectBarcodes(boolean shouldDetectBarcodes) {
-    if (shouldDetectBarcodes && mGoogleBarcodeDetector == null) {
-      setupBarcodeDetector();
-    }
-    this.mShouldGoogleDetectBarcodes = shouldDetectBarcodes;
-    setScanning(mShouldDetectFaces || mShouldGoogleDetectBarcodes || mShouldScanBarCodes || mShouldRecognizeText);
-  }
-
-  public void setGoogleVisionBarcodeType(int barcodeType) {
-    mGoogleVisionBarCodeType = barcodeType;
-    if (mGoogleBarcodeDetector != null) {
-      mGoogleBarcodeDetector.setBarcodeType(barcodeType);
-    }
-  }
-
-  public void setGoogleVisionBarcodeMode(int barcodeMode) {
-    mGoogleVisionBarCodeMode = barcodeMode;
-  }
-
-  public void onBarcodesDetected(WritableArray barcodesDetected, int width, int height, byte[] imageData) {
-    if (!mShouldGoogleDetectBarcodes) {
-      return;
-    }
-
-    // See discussion in https://github.com/react-native-community/react-native-camera/issues/2786
-    final byte[] compressedImage;
-    if (mDetectedImageInEvent) {
-      try {
-        // https://stackoverflow.com/a/32793908/122441
-        final YuvImage yuvImage = new YuvImage(imageData, ImageFormat.NV21, width, height, null);
-        final ByteArrayOutputStream imageStream = new ByteArrayOutputStream();
-        yuvImage.compressToJpeg(new Rect(0, 0, width, height), 100, imageStream);
-        compressedImage = imageStream.toByteArray();
-      } catch (Exception e) {
-        throw new RuntimeException(String.format("Error decoding imageData from NV21 format (%d bytes)", imageData.length), e);
-      }
-    } else {
-      compressedImage = null;
-    }
-
-    RNCameraViewHelper.emitBarcodesDetectedEvent(this, barcodesDetected, compressedImage);
-  }
-
-  public void onBarcodeDetectionError(RNBarcodeDetector barcodeDetector) {
-    if (!mShouldGoogleDetectBarcodes) {
-      return;
-    }
-
-    RNCameraViewHelper.emitBarcodeDetectionErrorEvent(this, barcodeDetector);
-  }
-
-  @Override
-  public void onBarcodeDetectingTaskCompleted() {
-    googleBarcodeDetectorTaskLock = false;
-  }
-
-  /**
-   *
-   * Text recognition
-   */
-
-  public void setShouldRecognizeText(boolean shouldRecognizeText) {
-    this.mShouldRecognizeText = shouldRecognizeText;
-    setScanning(mShouldDetectFaces || mShouldGoogleDetectBarcodes || mShouldScanBarCodes || mShouldRecognizeText);
-  }
-
-  public void onTextRecognized(WritableArray serializedData) {
-    if (!mShouldRecognizeText) {
-      return;
-    }
-
-    RNCameraViewHelper.emitTextRecognizedEvent(this, serializedData);
-  }
-
-  @Override
-  public void onTextRecognizerTaskCompleted() {
-    textRecognizerTaskLock = false;
-  }
-
-  /**
-  *
-  * End Text Recognition */
-
-  @Override
-  public void onHostResume() {
-    if (hasCameraPermissions()) {
-      mBgHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          if ((mIsPaused && !isCameraOpened()) || mIsNew) {
-            mIsPaused = false;
-            mIsNew = false;
-            start();
-          }
-        }
-      });
-    } else {
-      RNCameraViewHelper.emitMountErrorEvent(this, "Camera permissions not granted - component could not be rendered.");
-    }
-  }
-
-  @Override
-  public void onHostPause() {
-    if (mIsRecording) {
-      mIsRecordingInterrupted = true;
-    }
-    if (!mIsPaused && isCameraOpened()) {
-      mIsPaused = true;
-      stop();
-    }
-  }
-
-  @Override
-  public void onHostDestroy() {
-    if (mFaceDetector != null) {
-      mFaceDetector.release();
-    }
-    if (mGoogleBarcodeDetector != null) {
-      mGoogleBarcodeDetector.release();
-    }
-    mMultiFormatReader = null;
-    mThemedReactContext.removeLifecycleEventListener(this);
-
-    // camera release can be quite expensive. Run in on bg handler
-    // and cleanup last once everything has finished
-    mBgHandler.post(new Runnable() {
-        @Override
-        public void run() {
-          stop();
-          cleanup();
-        }
-      });
-  }
-  private void onZoom(float scale){
-    float currentZoom=getZoom();
-    float nextZoom=currentZoom+(scale-1.0f);
-
-    if(nextZoom > currentZoom){
-      setZoom(Math.min(nextZoom,1.0f));
-    }else{
-      setZoom(Math.max(nextZoom,0.0f));
-    }
-
-  }
-
-  private boolean hasCameraPermissions() {
-    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-      int result = ContextCompat.checkSelfPermission(getContext(), Manifest.permission.CAMERA);
-      return result == PackageManager.PERMISSION_GRANTED;
-    } else {
-      return true;
-    }
-  }
-  private int scalePosition(float raw){
-    Resources resources = getResources();
-    Configuration config = resources.getConfiguration();
-    DisplayMetrics dm = resources.getDisplayMetrics();
-    return (int)(raw/ dm.density);
-  }
-  private GestureDetector.SimpleOnGestureListener onGestureListener = new GestureDetector.SimpleOnGestureListener(){
-    @Override
-    public boolean onSingleTapUp(MotionEvent e) {
-      RNCameraViewHelper.emitTouchEvent(RNCameraView.this,false,scalePosition(e.getX()),scalePosition(e.getY()));
-      return true;
-    }
-
-    @Override
-    public boolean onDoubleTap(MotionEvent e) {
-      RNCameraViewHelper.emitTouchEvent(RNCameraView.this,true,scalePosition(e.getX()),scalePosition(e.getY()));
-      return true;
-    }
-  };
-  private ScaleGestureDetector.OnScaleGestureListener onScaleGestureListener = new ScaleGestureDetector.OnScaleGestureListener() {
-
-    @Override
-    public boolean onScale(ScaleGestureDetector scaleGestureDetector) {
-      onZoom(scaleGestureDetector.getScaleFactor());
-      return true;
-    }
-
-    @Override
-    public boolean onScaleBegin(ScaleGestureDetector scaleGestureDetector) {
-      onZoom(scaleGestureDetector.getScaleFactor());
-      return true;
-    }
-
-    @Override
-    public void onScaleEnd(ScaleGestureDetector scaleGestureDetector) {
-    }
-
-  };
-
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/RNCameraViewHelper.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/RNCameraViewHelper.java
deleted file mode 100644
index b5916e7..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/RNCameraViewHelper.java
+++ /dev/null
@@ -1,474 +0,0 @@
-package org.reactnative.camera;
-
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.media.CamcorderProfile;
-import android.os.Build;
-import androidx.exifinterface.media.ExifInterface;
-import android.view.ViewGroup;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.ReactContext;
-import com.facebook.react.bridge.ReadableMap;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.bridge.WritableArray;
-import com.facebook.react.uimanager.UIManagerModule;
-import com.google.android.cameraview.CameraView;
-import com.google.zxing.Result;
-import org.reactnative.camera.events.*;
-import org.reactnative.barcodedetector.RNBarcodeDetector;
-import org.reactnative.facedetector.RNFaceDetector;
-
-import java.text.SimpleDateFormat;
-import java.util.Calendar;
-
-public class RNCameraViewHelper {
-
-  public static final String[][] exifTags = new String[][]{
-      {"string", ExifInterface.TAG_ARTIST},
-      {"int", ExifInterface.TAG_BITS_PER_SAMPLE},
-      {"int", ExifInterface.TAG_COMPRESSION},
-      {"string", ExifInterface.TAG_COPYRIGHT},
-      {"string", ExifInterface.TAG_DATETIME},
-      {"string", ExifInterface.TAG_IMAGE_DESCRIPTION},
-      {"int", ExifInterface.TAG_IMAGE_LENGTH},
-      {"int", ExifInterface.TAG_IMAGE_WIDTH},
-      {"int", ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT},
-      {"int", ExifInterface.TAG_JPEG_INTERCHANGE_FORMAT_LENGTH},
-      {"string", ExifInterface.TAG_MAKE},
-      {"string", ExifInterface.TAG_MODEL},
-      {"int", ExifInterface.TAG_ORIENTATION},
-      {"int", ExifInterface.TAG_PHOTOMETRIC_INTERPRETATION},
-      {"int", ExifInterface.TAG_PLANAR_CONFIGURATION},
-      {"double", ExifInterface.TAG_PRIMARY_CHROMATICITIES},
-      {"double", ExifInterface.TAG_REFERENCE_BLACK_WHITE},
-      {"int", ExifInterface.TAG_RESOLUTION_UNIT},
-      {"int", ExifInterface.TAG_ROWS_PER_STRIP},
-      {"int", ExifInterface.TAG_SAMPLES_PER_PIXEL},
-      {"string", ExifInterface.TAG_SOFTWARE},
-      {"int", ExifInterface.TAG_STRIP_BYTE_COUNTS},
-      {"int", ExifInterface.TAG_STRIP_OFFSETS},
-      {"int", ExifInterface.TAG_TRANSFER_FUNCTION},
-      {"double", ExifInterface.TAG_WHITE_POINT},
-      {"double", ExifInterface.TAG_X_RESOLUTION},
-      {"double", ExifInterface.TAG_Y_CB_CR_COEFFICIENTS},
-      {"int", ExifInterface.TAG_Y_CB_CR_POSITIONING},
-      {"int", ExifInterface.TAG_Y_CB_CR_SUB_SAMPLING},
-      {"double", ExifInterface.TAG_Y_RESOLUTION},
-      {"double", ExifInterface.TAG_APERTURE_VALUE},
-      {"double", ExifInterface.TAG_BRIGHTNESS_VALUE},
-      {"string", ExifInterface.TAG_CFA_PATTERN},
-      {"int", ExifInterface.TAG_COLOR_SPACE},
-      {"string", ExifInterface.TAG_COMPONENTS_CONFIGURATION},
-      {"double", ExifInterface.TAG_COMPRESSED_BITS_PER_PIXEL},
-      {"int", ExifInterface.TAG_CONTRAST},
-      {"int", ExifInterface.TAG_CUSTOM_RENDERED},
-      {"string", ExifInterface.TAG_DATETIME_DIGITIZED},
-      {"string", ExifInterface.TAG_DATETIME_ORIGINAL},
-      {"string", ExifInterface.TAG_DEVICE_SETTING_DESCRIPTION},
-      {"double", ExifInterface.TAG_DIGITAL_ZOOM_RATIO},
-      {"string", ExifInterface.TAG_EXIF_VERSION},
-      {"double", ExifInterface.TAG_EXPOSURE_BIAS_VALUE},
-      {"double", ExifInterface.TAG_EXPOSURE_INDEX},
-      {"int", ExifInterface.TAG_EXPOSURE_MODE},
-      {"int", ExifInterface.TAG_EXPOSURE_PROGRAM},
-      {"double", ExifInterface.TAG_EXPOSURE_TIME},
-      {"double", ExifInterface.TAG_F_NUMBER},
-      {"string", ExifInterface.TAG_FILE_SOURCE},
-      {"int", ExifInterface.TAG_FLASH},
-      {"double", ExifInterface.TAG_FLASH_ENERGY},
-      {"string", ExifInterface.TAG_FLASHPIX_VERSION},
-      {"double", ExifInterface.TAG_FOCAL_LENGTH},
-      {"int", ExifInterface.TAG_FOCAL_LENGTH_IN_35MM_FILM},
-      {"int", ExifInterface.TAG_FOCAL_PLANE_RESOLUTION_UNIT},
-      {"double", ExifInterface.TAG_FOCAL_PLANE_X_RESOLUTION},
-      {"double", ExifInterface.TAG_FOCAL_PLANE_Y_RESOLUTION},
-      {"int", ExifInterface.TAG_GAIN_CONTROL},
-      {"int", ExifInterface.TAG_ISO_SPEED_RATINGS},
-      {"string", ExifInterface.TAG_IMAGE_UNIQUE_ID},
-      {"int", ExifInterface.TAG_LIGHT_SOURCE},
-      {"string", ExifInterface.TAG_MAKER_NOTE},
-      {"double", ExifInterface.TAG_MAX_APERTURE_VALUE},
-      {"int", ExifInterface.TAG_METERING_MODE},
-      {"int", ExifInterface.TAG_NEW_SUBFILE_TYPE},
-      {"string", ExifInterface.TAG_OECF},
-      {"int", ExifInterface.TAG_PIXEL_X_DIMENSION},
-      {"int", ExifInterface.TAG_PIXEL_Y_DIMENSION},
-      {"string", ExifInterface.TAG_RELATED_SOUND_FILE},
-      {"int", ExifInterface.TAG_SATURATION},
-      {"int", ExifInterface.TAG_SCENE_CAPTURE_TYPE},
-      {"string", ExifInterface.TAG_SCENE_TYPE},
-      {"int", ExifInterface.TAG_SENSING_METHOD},
-      {"int", ExifInterface.TAG_SHARPNESS},
-      {"double", ExifInterface.TAG_SHUTTER_SPEED_VALUE},
-      {"string", ExifInterface.TAG_SPATIAL_FREQUENCY_RESPONSE},
-      {"string", ExifInterface.TAG_SPECTRAL_SENSITIVITY},
-      {"int", ExifInterface.TAG_SUBFILE_TYPE},
-      {"string", ExifInterface.TAG_SUBSEC_TIME},
-      {"string", ExifInterface.TAG_SUBSEC_TIME_DIGITIZED},
-      {"string", ExifInterface.TAG_SUBSEC_TIME_ORIGINAL},
-      {"int", ExifInterface.TAG_SUBJECT_AREA},
-      {"double", ExifInterface.TAG_SUBJECT_DISTANCE},
-      {"int", ExifInterface.TAG_SUBJECT_DISTANCE_RANGE},
-      {"int", ExifInterface.TAG_SUBJECT_LOCATION},
-      {"string", ExifInterface.TAG_USER_COMMENT},
-      {"int", ExifInterface.TAG_WHITE_BALANCE},
-      {"int", ExifInterface.TAG_GPS_ALTITUDE_REF},
-      {"string", ExifInterface.TAG_GPS_AREA_INFORMATION},
-      {"double", ExifInterface.TAG_GPS_DOP},
-      {"string", ExifInterface.TAG_GPS_DATESTAMP},
-      {"double", ExifInterface.TAG_GPS_DEST_BEARING},
-      {"string", ExifInterface.TAG_GPS_DEST_BEARING_REF},
-      {"double", ExifInterface.TAG_GPS_DEST_DISTANCE},
-      {"string", ExifInterface.TAG_GPS_DEST_DISTANCE_REF},
-      {"double", ExifInterface.TAG_GPS_DEST_LATITUDE},
-      {"string", ExifInterface.TAG_GPS_DEST_LATITUDE_REF},
-      {"double", ExifInterface.TAG_GPS_DEST_LONGITUDE},
-      {"string", ExifInterface.TAG_GPS_DEST_LONGITUDE_REF},
-      {"int", ExifInterface.TAG_GPS_DIFFERENTIAL},
-      {"double", ExifInterface.TAG_GPS_IMG_DIRECTION},
-      {"string", ExifInterface.TAG_GPS_IMG_DIRECTION_REF},
-      {"string", ExifInterface.TAG_GPS_LATITUDE_REF},
-      {"string", ExifInterface.TAG_GPS_LONGITUDE_REF},
-      {"string", ExifInterface.TAG_GPS_MAP_DATUM},
-      {"string", ExifInterface.TAG_GPS_MEASURE_MODE},
-      {"string", ExifInterface.TAG_GPS_PROCESSING_METHOD},
-      {"string", ExifInterface.TAG_GPS_SATELLITES},
-      {"double", ExifInterface.TAG_GPS_SPEED},
-      {"string", ExifInterface.TAG_GPS_SPEED_REF},
-      {"string", ExifInterface.TAG_GPS_STATUS},
-      {"string", ExifInterface.TAG_GPS_TIMESTAMP},
-      {"double", ExifInterface.TAG_GPS_TRACK},
-      {"string", ExifInterface.TAG_GPS_TRACK_REF},
-      {"string", ExifInterface.TAG_GPS_VERSION_ID},
-      {"string", ExifInterface.TAG_INTEROPERABILITY_INDEX},
-      {"int", ExifInterface.TAG_THUMBNAIL_IMAGE_LENGTH},
-      {"int", ExifInterface.TAG_THUMBNAIL_IMAGE_WIDTH},
-      {"int", ExifInterface.TAG_DNG_VERSION},
-      {"int", ExifInterface.TAG_DEFAULT_CROP_SIZE},
-      {"int", ExifInterface.TAG_ORF_PREVIEW_IMAGE_START},
-      {"int", ExifInterface.TAG_ORF_PREVIEW_IMAGE_LENGTH},
-      {"int", ExifInterface.TAG_ORF_ASPECT_FRAME},
-      {"int", ExifInterface.TAG_RW2_SENSOR_BOTTOM_BORDER},
-      {"int", ExifInterface.TAG_RW2_SENSOR_LEFT_BORDER},
-      {"int", ExifInterface.TAG_RW2_SENSOR_RIGHT_BORDER},
-      {"int", ExifInterface.TAG_RW2_SENSOR_TOP_BORDER},
-      {"int", ExifInterface.TAG_RW2_ISO},
-  };
-
-  // Run all events on native modules queue thread since they might be fired
-  // from other non RN threads.
-
-
-  // Mount error event
-
-  public static void emitMountErrorEvent(final ViewGroup view, final String error) {
-
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        CameraMountErrorEvent event = CameraMountErrorEvent.obtain(view.getId(), error);
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-    });
-  }
-
-  // Camera ready event
-
-  public static void emitCameraReadyEvent(final ViewGroup view) {
-
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        CameraReadyEvent event = CameraReadyEvent.obtain(view.getId());
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-    });
-  }
-
-  // Picture saved event
-
-  public static void emitPictureSavedEvent(final ViewGroup view, final WritableMap response) {
-
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        PictureSavedEvent event = PictureSavedEvent.obtain(view.getId(), response);
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-    });
-
-  }
-
-  // Picture taken event
-
-  public static void emitPictureTakenEvent(final ViewGroup view) {
-
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        PictureTakenEvent event = PictureTakenEvent.obtain(view.getId());
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-     });
-  }
-
-  // video recording start/end events
-
-  public static void emitRecordingStartEvent(final ViewGroup view, final WritableMap response) {
-
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        RecordingStartEvent event = RecordingStartEvent.obtain(view.getId(), response);
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-     });
-  }
-
-  public static void emitRecordingEndEvent(final ViewGroup view) {
-
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        RecordingEndEvent event = RecordingEndEvent.obtain(view.getId());
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-     });
-  }
-  // Touch event
-  public static void emitTouchEvent(final ViewGroup view, final boolean isDoubleTap, final int x, final int y) {
-
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        TouchEvent event = TouchEvent.obtain(view.getId(), isDoubleTap, x, y);
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-    });
-
-  }
-  // Face detection events
-
-  public static void emitFacesDetectedEvent(final ViewGroup view, final WritableArray data) {
-
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        FacesDetectedEvent event = FacesDetectedEvent.obtain(view.getId(), data);
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-     });
-  }
-
-  public static void emitFaceDetectionErrorEvent(final ViewGroup view, final RNFaceDetector faceDetector) {
-
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        FaceDetectionErrorEvent event = FaceDetectionErrorEvent.obtain(view.getId(), faceDetector);
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-    });
-  }
-
-  // Barcode detection events
-
-  public static void emitBarcodesDetectedEvent(final ViewGroup view, final WritableArray barcodes, final byte[] compressedImage) {
-
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        BarcodesDetectedEvent event = BarcodesDetectedEvent.obtain(view.getId(), barcodes, compressedImage);
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-    });
-  }
-
-  public static void emitBarcodeDetectionErrorEvent(final ViewGroup view, final RNBarcodeDetector barcodeDetector) {
-
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        BarcodeDetectionErrorEvent event = BarcodeDetectionErrorEvent.obtain(view.getId(), barcodeDetector);
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-    });
-  }
-
-  // Bar code read event
-
-  public static void emitBarCodeReadEvent(final ViewGroup view, final Result barCode, final int width, final int height, final byte[] compressedImage) {
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        BarCodeReadEvent event = BarCodeReadEvent.obtain(view.getId(), barCode, width,  height, compressedImage);
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-    });
-  }
-
-  // Text recognition event
-
-  public static void emitTextRecognizedEvent(final ViewGroup view, final WritableArray data) {
-    final ReactContext reactContext = (ReactContext) view.getContext();
-    reactContext.runOnNativeModulesQueueThread(new Runnable() {
-      @Override
-      public void run() {
-        TextRecognizedEvent event = TextRecognizedEvent.obtain(view.getId(), data);
-        reactContext.getNativeModule(UIManagerModule.class).getEventDispatcher().dispatchEvent(event);
-      }
-    });
-  }
-
-  // Utilities
-
-  public static int getCorrectCameraRotation(int rotation, int facing, int cameraOrientation) {
-    if (facing == CameraView.FACING_FRONT) {
-      // Tested the below line and there's no need to do the mirror calculation
-      return (cameraOrientation + rotation) % 360;
-    } else {
-      final int landscapeFlip = rotationIsLandscape(rotation) ? 180 : 0;
-      return (cameraOrientation - rotation + landscapeFlip) % 360;
-    }
-  }
-
-  private static boolean rotationIsLandscape(int rotation) {
-    return (rotation == Constants.LANDSCAPE_90 ||
-            rotation == Constants.LANDSCAPE_270);
-  }
-
-  private static int getCamcorderProfileQualityFromCameraModuleConstant(int quality) {
-    switch (quality) {
-      case CameraModule.VIDEO_2160P:
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-          return CamcorderProfile.QUALITY_2160P;
-        }
-      case CameraModule.VIDEO_1080P:
-        return CamcorderProfile.QUALITY_1080P;
-      case CameraModule.VIDEO_720P:
-        return CamcorderProfile.QUALITY_720P;
-      case CameraModule.VIDEO_480P:
-        return CamcorderProfile.QUALITY_480P;
-      case CameraModule.VIDEO_4x3:
-        return CamcorderProfile.QUALITY_480P;
-    }
-    return CamcorderProfile.QUALITY_HIGH;
-  }
-
-  public static CamcorderProfile getCamcorderProfile(int quality) {
-    CamcorderProfile profile = CamcorderProfile.get(CamcorderProfile.QUALITY_HIGH);
-    int camcorderQuality = getCamcorderProfileQualityFromCameraModuleConstant(quality);
-    if (CamcorderProfile.hasProfile(camcorderQuality)) {
-      profile = CamcorderProfile.get(camcorderQuality);
-      if (quality == CameraModule.VIDEO_4x3) {
-        profile.videoFrameWidth = 640;
-      }
-    }
-    return profile;
-  }
-
-  public static WritableMap getExifData(ExifInterface exifInterface) {
-    WritableMap exifMap = Arguments.createMap();
-    for (String[] tagInfo : exifTags) {
-      String name = tagInfo[1];
-      if (exifInterface.getAttribute(name) != null) {
-        String type = tagInfo[0];
-        switch (type) {
-          case "string":
-            exifMap.putString(name, exifInterface.getAttribute(name));
-            break;
-          case "int":
-            exifMap.putInt(name, exifInterface.getAttributeInt(name, 0));
-            break;
-          case "double":
-            exifMap.putDouble(name, exifInterface.getAttributeDouble(name, 0));
-            break;
-        }
-      }
-    }
-
-    double[] latLong = exifInterface.getLatLong();
-    if (latLong != null) {
-      exifMap.putDouble(ExifInterface.TAG_GPS_LATITUDE, latLong[0]);
-      exifMap.putDouble(ExifInterface.TAG_GPS_LONGITUDE, latLong[1]);
-      exifMap.putDouble(ExifInterface.TAG_GPS_ALTITUDE, exifInterface.getAltitude(0));
-    }
-
-    return exifMap;
-  }
-
-  public static void setExifData(ExifInterface exifInterface, ReadableMap exifMap) {
-    for (String[] tagInfo : exifTags) {
-      String name = tagInfo[1];
-      if (exifMap.hasKey(name)) {
-        String type = tagInfo[0];
-        switch (type) {
-          case "string":
-            exifInterface.setAttribute(name, exifMap.getString(name));
-            break;
-          case "int":
-            exifInterface.setAttribute(name, Integer.toString(exifMap.getInt(name)));
-            exifMap.getInt(name);
-            break;
-          case "double":
-            exifInterface.setAttribute(name, Double.toString(exifMap.getDouble(name)));
-            exifMap.getDouble(name);
-            break;
-        }
-      }
-    }
-
-    if (exifMap.hasKey(ExifInterface.TAG_GPS_LATITUDE) && exifMap.hasKey(ExifInterface.TAG_GPS_LONGITUDE)) {
-      exifInterface.setLatLong(exifMap.getDouble(ExifInterface.TAG_GPS_LATITUDE),
-                               exifMap.getDouble(ExifInterface.TAG_GPS_LONGITUDE));
-    }
-    if(exifMap.hasKey(ExifInterface.TAG_GPS_ALTITUDE)){
-      exifInterface.setAltitude(exifMap.getDouble(ExifInterface.TAG_GPS_ALTITUDE));
-    }
-  }
-
-  // clears exif values in place
-  public static void clearExifData(ExifInterface exifInterface) {
-    for (String[] tagInfo : exifTags) {
-      exifInterface.setAttribute(tagInfo[1], null);
-    }
-
-    // these are not part of our tag list, remove by hand
-    exifInterface.setAttribute(ExifInterface.TAG_GPS_LATITUDE, null);
-    exifInterface.setAttribute(ExifInterface.TAG_GPS_LONGITUDE, null);
-    exifInterface.setAttribute(ExifInterface.TAG_GPS_ALTITUDE, null);
-  }
-
-  public static Bitmap generateSimulatorPhoto(int width, int height) {
-    Bitmap fakePhoto = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-    Canvas canvas = new Canvas(fakePhoto);
-    Paint background = new Paint();
-    background.setColor(Color.BLACK);
-    canvas.drawRect(0, 0, width, height, background);
-    Paint textPaint = new Paint();
-    textPaint.setColor(Color.YELLOW);
-    textPaint.setTextSize(35);
-    Calendar calendar = Calendar.getInstance();
-    SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy.MM.dd G '->' HH:mm:ss z");
-    canvas.drawText(simpleDateFormat.format(calendar.getTime()), width * 0.1f, height * 0.2f, textPaint);
-    canvas.drawText(simpleDateFormat.format(calendar.getTime()), width * 0.2f, height * 0.4f, textPaint);
-    canvas.drawText(simpleDateFormat.format(calendar.getTime()), width * 0.3f, height * 0.6f, textPaint);
-    canvas.drawText(simpleDateFormat.format(calendar.getTime()), width * 0.4f, height * 0.8f, textPaint);
-
-    return fakePhoto;
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/BarCodeReadEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/BarCodeReadEvent.java
deleted file mode 100644
index c3885a4..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/BarCodeReadEvent.java
+++ /dev/null
@@ -1,107 +0,0 @@
-package org.reactnative.camera.events;
-
-import android.util.Base64;
-
-import androidx.core.util.Pools;
-
-import org.reactnative.camera.CameraViewManager;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.WritableArray;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-import com.google.zxing.Result;
-import com.google.zxing.ResultPoint;
-
-import java.util.Formatter;
-
-public class BarCodeReadEvent extends Event<BarCodeReadEvent> {
-  private static final Pools.SynchronizedPool<BarCodeReadEvent> EVENTS_POOL =
-      new Pools.SynchronizedPool<>(3);
-
-  private Result mBarCode;
-  private int mWidth;
-  private int mHeight;
-  private byte[] mCompressedImage;
-
-  private BarCodeReadEvent() {}
-
-  public static BarCodeReadEvent obtain(int viewTag, Result barCode, int width, int height, byte[] compressedImage) {
-    BarCodeReadEvent event = EVENTS_POOL.acquire();
-    if (event == null) {
-      event = new BarCodeReadEvent();
-    }
-    event.init(viewTag, barCode, width, height, compressedImage);
-    return event;
-  }
-
-  private void init(int viewTag, Result barCode, int width, int height, byte[] compressedImage) {
-    super.init(viewTag);
-    mBarCode = barCode;
-    mWidth = width;
-    mHeight = height;
-    mCompressedImage = compressedImage;
-  }
-
-  /**
-   * We want every distinct barcode to be reported to the JS listener.
-   * If we return some static value as a coalescing key there may be two barcode events
-   * containing two different barcodes waiting to be transmitted to JS
-   * that would get coalesced (because both of them would have the same coalescing key).
-   * So let's differentiate them with a hash of the contents (mod short's max value).
-   */
-  @Override
-  public short getCoalescingKey() {
-    int hashCode = mBarCode.getText().hashCode() % Short.MAX_VALUE;
-    return (short) hashCode;
-  }
-
-  @Override
-  public String getEventName() {
-    return CameraViewManager.Events.EVENT_ON_BAR_CODE_READ.toString();
-  }
-
-  @Override
-  public void dispatch(RCTEventEmitter rctEventEmitter) {
-    rctEventEmitter.receiveEvent(getViewTag(), getEventName(), serializeEventData());
-  }
-
-  private WritableMap serializeEventData() {
-    WritableMap event = Arguments.createMap();
-    WritableMap eventOrigin = Arguments.createMap();
-
-    event.putInt("target", getViewTag());
-    event.putString("data", mBarCode.getText());
-
-    byte[] rawBytes = mBarCode.getRawBytes();
-    if (rawBytes != null && rawBytes.length > 0) {
-      Formatter formatter = new Formatter();
-      for (byte b : rawBytes) {
-        formatter.format("%02x", b);
-      }
-      event.putString("rawData", formatter.toString());
-      formatter.close();
-    } 
-
-    event.putString("type", mBarCode.getBarcodeFormat().toString());
-    WritableArray resultPoints = Arguments.createArray();
-    ResultPoint[] points = mBarCode.getResultPoints();
-    for (ResultPoint point: points) {
-      if(point!=null) {
-        WritableMap newPoint = Arguments.createMap();
-        newPoint.putString("x", String.valueOf(point.getX()));
-        newPoint.putString("y", String.valueOf(point.getY()));
-        resultPoints.pushMap(newPoint);
-      }
-    }
-
-    eventOrigin.putArray("origin", resultPoints);
-    eventOrigin.putInt("height", mHeight);
-    eventOrigin.putInt("width", mWidth);
-    event.putMap("bounds", eventOrigin);
-    if (mCompressedImage != null) {
-      event.putString("image", Base64.encodeToString(mCompressedImage, Base64.NO_WRAP));
-    }
-    return event;
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/BarcodeDetectionErrorEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/BarcodeDetectionErrorEvent.java
deleted file mode 100644
index e6db6d4..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/BarcodeDetectionErrorEvent.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package org.reactnative.camera.events;
-
-import androidx.core.util.Pools;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-import org.reactnative.camera.CameraViewManager;
-import org.reactnative.barcodedetector.RNBarcodeDetector;
-
-public class BarcodeDetectionErrorEvent extends Event<BarcodeDetectionErrorEvent> {
-
-  private static final Pools.SynchronizedPool<BarcodeDetectionErrorEvent> EVENTS_POOL = new Pools.SynchronizedPool<>(3);
-  private RNBarcodeDetector mBarcodeDetector;
-
-  private BarcodeDetectionErrorEvent() {
-  }
-
-  public static BarcodeDetectionErrorEvent obtain(int viewTag, RNBarcodeDetector barcodeDetector) {
-    BarcodeDetectionErrorEvent event = EVENTS_POOL.acquire();
-    if (event == null) {
-      event = new BarcodeDetectionErrorEvent();
-    }
-    event.init(viewTag, barcodeDetector);
-    return event;
-  }
-
-  private void init(int viewTag, RNBarcodeDetector faceDetector) {
-    super.init(viewTag);
-    mBarcodeDetector = faceDetector;
-  }
-
-  @Override
-  public short getCoalescingKey() {
-    return 0;
-  }
-
-  @Override
-  public String getEventName() {
-    return CameraViewManager.Events.EVENT_ON_BARCODE_DETECTION_ERROR.toString();
-  }
-
-  @Override
-  public void dispatch(RCTEventEmitter rctEventEmitter) {
-    rctEventEmitter.receiveEvent(getViewTag(), getEventName(), serializeEventData());
-  }
-
-  private WritableMap serializeEventData() {
-    WritableMap map = Arguments.createMap();
-    map.putBoolean("isOperational", mBarcodeDetector != null && mBarcodeDetector.isOperational());
-    return map;
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/BarcodesDetectedEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/BarcodesDetectedEvent.java
deleted file mode 100644
index 56e2511..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/BarcodesDetectedEvent.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package org.reactnative.camera.events;
-
-import android.util.Base64;
-
-import androidx.core.util.Pools;
-
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.WritableArray;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-import org.reactnative.camera.CameraViewManager;
-
-public class BarcodesDetectedEvent extends Event<BarcodesDetectedEvent> {
-
-  private static final Pools.SynchronizedPool<BarcodesDetectedEvent> EVENTS_POOL =
-      new Pools.SynchronizedPool<>(3);
-
-  private WritableArray mBarcodes;
-  private byte[] mCompressedImage;
-
-  private BarcodesDetectedEvent() {
-  }
-
-  public static BarcodesDetectedEvent obtain(
-          int viewTag,
-          WritableArray barcodes,
-          byte[] compressedImage) {
-    BarcodesDetectedEvent event = EVENTS_POOL.acquire();
-    if (event == null) {
-      event = new BarcodesDetectedEvent();
-    }
-    event.init(viewTag, barcodes, compressedImage);
-    return event;
-  }
-
-  private void init(
-          int viewTag,
-          WritableArray barcodes,
-          byte[] compressedImage) {
-    super.init(viewTag);
-    mBarcodes = barcodes;
-    mCompressedImage = compressedImage;
-  }
-
-  /**
-   * note(@sjchmiela)
-   * Should the events about detected barcodes coalesce, the best strategy will be
-   * to ensure that events with different barcodes count are always being transmitted.
-   */
-  @Override
-  public short getCoalescingKey() {
-    if (mBarcodes.size() > Short.MAX_VALUE) {
-      return Short.MAX_VALUE;
-    }
-
-    return (short) mBarcodes.size();
-  }
-
-  @Override
-  public String getEventName() {
-    return CameraViewManager.Events.EVENT_ON_BARCODES_DETECTED.toString();
-  }
-
-  @Override
-  public void dispatch(RCTEventEmitter rctEventEmitter) {
-    rctEventEmitter.receiveEvent(getViewTag(), getEventName(), serializeEventData());
-  }
-
-  private WritableMap serializeEventData() {
-    WritableMap event = Arguments.createMap();
-    event.putString("type", "barcode");
-    event.putArray("barcodes", mBarcodes);
-    event.putInt("target", getViewTag());
-    if (mCompressedImage != null) {
-      event.putString("image", Base64.encodeToString(mCompressedImage, Base64.NO_WRAP));
-    }
-    return event;
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/CameraMountErrorEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/CameraMountErrorEvent.java
deleted file mode 100644
index 5f7c160..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/CameraMountErrorEvent.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package org.reactnative.camera.events;
-
-import androidx.core.util.Pools;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-import org.reactnative.camera.CameraViewManager;
-
-public class CameraMountErrorEvent extends Event<CameraMountErrorEvent> {
-  private static final Pools.SynchronizedPool<CameraMountErrorEvent> EVENTS_POOL = new Pools.SynchronizedPool<>(3);
-  private String mError;
-
-  private CameraMountErrorEvent() {
-  }
-
-  public static CameraMountErrorEvent obtain(int viewTag, String error) {
-    CameraMountErrorEvent event = EVENTS_POOL.acquire();
-    if (event == null) {
-      event = new CameraMountErrorEvent();
-    }
-    event.init(viewTag, error);
-    return event;
-  }
-
-  private void init(int viewTag, String error) {
-    super.init(viewTag);
-    mError = error;
-  }
-
-  @Override
-  public short getCoalescingKey() {
-    return 0;
-  }
-
-  @Override
-  public String getEventName() {
-    return CameraViewManager.Events.EVENT_ON_MOUNT_ERROR.toString();
-  }
-
-  @Override
-  public void dispatch(RCTEventEmitter rctEventEmitter) {
-    rctEventEmitter.receiveEvent(getViewTag(), getEventName(), serializeEventData());
-  }
-
-  private WritableMap serializeEventData() {
-    WritableMap arguments = Arguments.createMap();
-    arguments.putString("message", mError);
-    return arguments;
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/CameraReadyEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/CameraReadyEvent.java
deleted file mode 100644
index ed41221..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/CameraReadyEvent.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.reactnative.camera.events;
-
-import androidx.core.util.Pools;
-
-import org.reactnative.camera.CameraViewManager;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-
-public class CameraReadyEvent extends Event<CameraReadyEvent> {
-  private static final Pools.SynchronizedPool<CameraReadyEvent> EVENTS_POOL = new Pools.SynchronizedPool<>(3);
-  private CameraReadyEvent() {}
-
-  public static CameraReadyEvent obtain(int viewTag) {
-    CameraReadyEvent event = EVENTS_POOL.acquire();
-    if (event == null) {
-      event = new CameraReadyEvent();
-    }
-    event.init(viewTag);
-    return event;
-  }
-
-  @Override
-  public short getCoalescingKey() {
-    return 0;
-  }
-
-  @Override
-  public String getEventName() {
-    return CameraViewManager.Events.EVENT_CAMERA_READY.toString();
-  }
-
-  @Override
-  public void dispatch(RCTEventEmitter rctEventEmitter) {
-    rctEventEmitter.receiveEvent(getViewTag(), getEventName(), serializeEventData());
-  }
-
-  private WritableMap serializeEventData() {
-    return Arguments.createMap();
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/FaceDetectionErrorEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/FaceDetectionErrorEvent.java
deleted file mode 100644
index 72f7a66..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/FaceDetectionErrorEvent.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package org.reactnative.camera.events;
-
-import androidx.core.util.Pools;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-import org.reactnative.camera.CameraViewManager;
-import org.reactnative.facedetector.RNFaceDetector;
-
-public class FaceDetectionErrorEvent extends Event<FaceDetectionErrorEvent> {
-  private static final Pools.SynchronizedPool<FaceDetectionErrorEvent> EVENTS_POOL = new Pools.SynchronizedPool<>(3);
-  private RNFaceDetector mFaceDetector;
-
-  private FaceDetectionErrorEvent() {
-  }
-
-  public static FaceDetectionErrorEvent obtain(int viewTag, RNFaceDetector faceDetector) {
-    FaceDetectionErrorEvent event = EVENTS_POOL.acquire();
-    if (event == null) {
-      event = new FaceDetectionErrorEvent();
-    }
-    event.init(viewTag, faceDetector);
-    return event;
-  }
-
-  private void init(int viewTag, RNFaceDetector faceDetector) {
-    super.init(viewTag);
-    mFaceDetector = faceDetector;
-  }
-
-  @Override
-  public short getCoalescingKey() {
-    return 0;
-  }
-
-  @Override
-  public String getEventName() {
-    return CameraViewManager.Events.EVENT_ON_FACE_DETECTION_ERROR.toString();
-  }
-
-  @Override
-  public void dispatch(RCTEventEmitter rctEventEmitter) {
-    rctEventEmitter.receiveEvent(getViewTag(), getEventName(), serializeEventData());
-  }
-
-  private WritableMap serializeEventData() {
-    WritableMap map = Arguments.createMap();
-    map.putBoolean("isOperational", mFaceDetector != null && mFaceDetector.isOperational());
-    return map;
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/FacesDetectedEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/FacesDetectedEvent.java
deleted file mode 100644
index ae93e9a..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/FacesDetectedEvent.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package org.reactnative.camera.events;
-
-import androidx.core.util.Pools;
-
-import org.reactnative.camera.CameraViewManager;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.WritableArray;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-
-public class FacesDetectedEvent extends Event<FacesDetectedEvent> {
-  private static final Pools.SynchronizedPool<FacesDetectedEvent> EVENTS_POOL =
-      new Pools.SynchronizedPool<>(3);
-
-  private WritableArray mData;
-
-  private FacesDetectedEvent() {}
-
-  public static FacesDetectedEvent obtain(int viewTag, WritableArray data) {
-    FacesDetectedEvent event = EVENTS_POOL.acquire();
-    if (event == null) {
-      event = new FacesDetectedEvent();
-    }
-    event.init(viewTag, data);
-    return event;
-  }
-
-  private void init(int viewTag, WritableArray data) {
-    super.init(viewTag);
-    mData = data;
-  }
-
-  /**
-   * note(@sjchmiela)
-   * Should the events about detected faces coalesce, the best strategy will be
-   * to ensure that events with different faces count are always being transmitted.
-   */
-  @Override
-  public short getCoalescingKey() {
-    if (mData.size() > Short.MAX_VALUE) {
-      return Short.MAX_VALUE;
-    }
-
-    return (short) mData.size();
-  }
-
-  @Override
-  public String getEventName() {
-    return CameraViewManager.Events.EVENT_ON_FACES_DETECTED.toString();
-  }
-
-  @Override
-  public void dispatch(RCTEventEmitter rctEventEmitter) {
-    rctEventEmitter.receiveEvent(getViewTag(), getEventName(), serializeEventData());
-  }
-
-  private WritableMap serializeEventData() {
-    WritableMap event = Arguments.createMap();
-    event.putString("type", "face");
-    event.putArray("faces", mData);
-    event.putInt("target", getViewTag());
-    return event;
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/PictureSavedEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/PictureSavedEvent.java
deleted file mode 100644
index 305c543..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/PictureSavedEvent.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.reactnative.camera.events;
-
-import androidx.core.util.Pools;
-
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-
-import org.reactnative.camera.CameraViewManager;
-
-public class PictureSavedEvent extends Event<PictureSavedEvent> {
-    private static final Pools.SynchronizedPool<PictureSavedEvent> EVENTS_POOL = new Pools.SynchronizedPool<>(5);
-    private PictureSavedEvent() {}
-    
-    private WritableMap mResponse;
-    
-    public static PictureSavedEvent obtain(int viewTag, WritableMap response) {
-        PictureSavedEvent event = EVENTS_POOL.acquire();
-        if (event == null) {
-            event = new PictureSavedEvent();
-        }
-        event.init(viewTag, response);
-        return event;
-    }
-    
-    private void init(int viewTag, WritableMap response) {
-        super.init(viewTag);
-        mResponse = response;
-    }
-    
-    @Override
-    public short getCoalescingKey() {
-        int hashCode = mResponse.getMap("data").getString("uri").hashCode() % Short.MAX_VALUE;
-        return (short) hashCode;
-    }
-    
-    @Override
-    public String getEventName() {
-        return CameraViewManager.Events.EVENT_ON_PICTURE_SAVED.toString();
-    }
-    
-    @Override
-    public void dispatch(RCTEventEmitter rctEventEmitter) {
-        rctEventEmitter.receiveEvent(getViewTag(), getEventName(), mResponse);
-    }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/PictureTakenEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/PictureTakenEvent.java
deleted file mode 100644
index b1247a3..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/PictureTakenEvent.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.reactnative.camera.events;
-
-import androidx.core.util.Pools;
-
-import org.reactnative.camera.CameraViewManager;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-
-public class PictureTakenEvent extends Event<PictureTakenEvent> {
-  private static final Pools.SynchronizedPool<PictureTakenEvent> EVENTS_POOL = new Pools.SynchronizedPool<>(3);
-  private PictureTakenEvent() {}
-
-  public static PictureTakenEvent obtain(int viewTag) {
-    PictureTakenEvent event = EVENTS_POOL.acquire();
-    if (event == null) {
-      event = new PictureTakenEvent();
-    }
-    event.init(viewTag);
-    return event;
-  }
-
-  @Override
-  public short getCoalescingKey() {
-    return 0;
-  }
-
-  @Override
-  public String getEventName() {
-    return CameraViewManager.Events.EVENT_ON_PICTURE_TAKEN.toString();
-  }
-
-  @Override
-  public void dispatch(RCTEventEmitter rctEventEmitter) {
-    rctEventEmitter.receiveEvent(getViewTag(), getEventName(), serializeEventData());
-  }
-
-  private WritableMap serializeEventData() {
-    return Arguments.createMap();
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/RecordingEndEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/RecordingEndEvent.java
deleted file mode 100644
index 8df213e..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/RecordingEndEvent.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package org.reactnative.camera.events;
-
-import androidx.core.util.Pools;
-
-import org.reactnative.camera.CameraViewManager;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-
-public class RecordingEndEvent extends Event<RecordingEndEvent> {
-    private static final Pools.SynchronizedPool<RecordingEndEvent> EVENTS_POOL = new Pools.SynchronizedPool<>(3);
-    private RecordingEndEvent() {}
-
-    public static RecordingEndEvent obtain(int viewTag) {
-        RecordingEndEvent event = EVENTS_POOL.acquire();
-        if (event == null) {
-        event = new RecordingEndEvent();
-        }
-        event.init(viewTag);
-        return event;
-    }
-
-    @Override
-    public short getCoalescingKey() {
-        return 0;
-    }
-
-    @Override
-    public String getEventName() {
-        return CameraViewManager.Events.EVENT_ON_RECORDING_END.toString();
-    }
-
-    @Override
-    public void dispatch(RCTEventEmitter rctEventEmitter) {
-        rctEventEmitter.receiveEvent(getViewTag(), getEventName(), serializeEventData());
-    }
-
-    private WritableMap serializeEventData() {
-        return Arguments.createMap();
-    }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/RecordingStartEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/RecordingStartEvent.java
deleted file mode 100644
index 0c7df40..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/RecordingStartEvent.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package org.reactnative.camera.events;
-
-import androidx.core.util.Pools;
-
-import org.reactnative.camera.CameraViewManager;
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-
-public class RecordingStartEvent extends Event<RecordingStartEvent> {
-    private static final Pools.SynchronizedPool<RecordingStartEvent> EVENTS_POOL = new Pools.SynchronizedPool<>(3);
-    private RecordingStartEvent() {}
-
-    private WritableMap mResponse;
-
-    public static RecordingStartEvent obtain(int viewTag, WritableMap response) {
-        RecordingStartEvent event = EVENTS_POOL.acquire();
-        if (event == null) {
-        event = new RecordingStartEvent();
-        }
-        event.init(viewTag, response);
-        return event;
-    }
-
-    private void init(int viewTag, WritableMap response) {
-        super.init(viewTag);
-        mResponse = response;
-    }
-
-    // @Override
-    // public short getCoalescingKey() {
-    //     int hashCode = mResponse.getString("uri").hashCode() % Short.MAX_VALUE;
-    //     return (short) hashCode;
-    // }
-
-    @Override
-    public String getEventName() {
-        return CameraViewManager.Events.EVENT_ON_RECORDING_START.toString();
-    }
-
-    @Override
-    public void dispatch(RCTEventEmitter rctEventEmitter) {
-        rctEventEmitter.receiveEvent(getViewTag(), getEventName(), mResponse);
-    }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/TextRecognizedEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/TextRecognizedEvent.java
deleted file mode 100644
index f785db3..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/TextRecognizedEvent.java
+++ /dev/null
@@ -1,54 +0,0 @@
-package org.reactnative.camera.events;
-
-import androidx.core.util.Pools;
-
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.WritableArray;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-
-import org.reactnative.camera.CameraViewManager;
-
-
-public class TextRecognizedEvent extends Event<TextRecognizedEvent> {
-
-  private static final Pools.SynchronizedPool<TextRecognizedEvent> EVENTS_POOL =
-      new Pools.SynchronizedPool<>(3);
-
-  private WritableArray mData;
-
-  private TextRecognizedEvent() {}
-
-  public static TextRecognizedEvent obtain(int viewTag, WritableArray data) {
-    TextRecognizedEvent event = EVENTS_POOL.acquire();
-    if (event == null) {
-      event = new TextRecognizedEvent();
-    }
-    event.init(viewTag, data);
-    return event;
-  }
-
-  private void init(int viewTag, WritableArray data) {
-    super.init(viewTag);
-    mData = data;
-  }
-
-  @Override
-  public String getEventName() {
-    return CameraViewManager.Events.EVENT_ON_TEXT_RECOGNIZED.toString();
-  }
-
-  @Override
-  public void dispatch(RCTEventEmitter rctEventEmitter) {
-    rctEventEmitter.receiveEvent(getViewTag(), getEventName(), createEvent());
-  }
-
-  private WritableMap createEvent() {
-    WritableMap event = Arguments.createMap();
-    event.putString("type", "textBlock");
-    event.putArray("textBlocks", mData);
-    event.putInt("target", getViewTag());
-    return event;
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/TouchEvent.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/TouchEvent.java
deleted file mode 100644
index 1e0fc99..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/events/TouchEvent.java
+++ /dev/null
@@ -1,69 +0,0 @@
-package org.reactnative.camera.events;
-
-import androidx.core.util.Pools;
-
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.WritableMap;
-import com.facebook.react.uimanager.events.Event;
-import com.facebook.react.uimanager.events.RCTEventEmitter;
-
-
-import org.reactnative.camera.CameraViewManager;
-
-
-public class TouchEvent extends Event<TouchEvent> {
-  private static final Pools.SynchronizedPool<TouchEvent> EVENTS_POOL =
-      new Pools.SynchronizedPool<>(3);
-
-  private int mX;
-  private int mY;
-  private boolean mIsDoubleTap;
-
-  private TouchEvent() {}
-
-  public static TouchEvent obtain(int viewTag, boolean isDoubleTap, int x, int y) {
-    TouchEvent event = EVENTS_POOL.acquire();
-    if (event == null) {
-      event = new TouchEvent();
-    }
-    event.init(viewTag, isDoubleTap, x, y);
-    return event;
-  }
-
-  private void init(int viewTag, boolean isDoubleTap, int x, int y) {
-    super.init(viewTag);
-    mX = x;
-    mY = y;
-    mIsDoubleTap=isDoubleTap;
-  }
-
-
-  @Override
-  public short getCoalescingKey() {
-    return 0;
-  }
-
-  @Override
-  public String getEventName() {
-    return CameraViewManager.Events.EVENT_ON_TOUCH.toString();
-  }
-
-  @Override
-  public void dispatch(RCTEventEmitter rctEventEmitter) {
-    rctEventEmitter.receiveEvent(getViewTag(), getEventName(), serializeEventData());
-  }
-
-  private WritableMap serializeEventData() {
-    WritableMap event = Arguments.createMap();
-
-    event.putInt("target", getViewTag());
-
-    WritableMap touchOrigin = Arguments.createMap();
-    touchOrigin.putInt("x", mX);
-    touchOrigin.putInt("y",mY);
-
-    event.putBoolean("isDoubleTap", mIsDoubleTap);
-    event.putMap("touchOrigin", touchOrigin);
-    return event;
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/BarCodeScannerAsyncTask.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/BarCodeScannerAsyncTask.java
deleted file mode 100644
index 587da61..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/BarCodeScannerAsyncTask.java
+++ /dev/null
@@ -1,193 +0,0 @@
-package org.reactnative.camera.tasks;
-
-import com.google.zxing.BinaryBitmap;
-import com.google.zxing.MultiFormatReader;
-import com.google.zxing.NotFoundException;
-import com.google.zxing.PlanarYUVLuminanceSource;
-import com.google.zxing.Result;
-import com.google.zxing.common.HybridBinarizer;
-
-public class BarCodeScannerAsyncTask extends android.os.AsyncTask<Void, Void, Result> {
-  private byte[] mImageData;
-  private int mWidth;
-  private int mHeight;
-  private BarCodeScannerAsyncTaskDelegate mDelegate;
-  private final MultiFormatReader mMultiFormatReader;
-  private boolean mLimitScanArea;
-  private float mScanAreaX;
-  private float mScanAreaY;
-  private float mScanAreaWidth;
-  private float mScanAreaHeight;
-  private int mCameraViewWidth;
-  private int mCameraViewHeight;
-  private float mRatio;
-
-  //  note(sjchmiela): From my short research it's ok to ignore rotation of the image.
-  public BarCodeScannerAsyncTask(
-      BarCodeScannerAsyncTaskDelegate delegate,
-      MultiFormatReader multiFormatReader,
-      byte[] imageData,
-      int width,
-      int height,
-      boolean limitScanArea,
-      float scanAreaX,
-      float scanAreaY,
-      float scanAreaWidth,
-      float scanAreaHeight,
-      int cameraViewWidth,
-      int cameraViewHeight,
-      float ratio
-  ) {
-    mImageData = imageData;
-    mWidth = width;
-    mHeight = height;
-    mDelegate = delegate;
-    mMultiFormatReader = multiFormatReader;
-    mLimitScanArea = limitScanArea;
-    mScanAreaX = scanAreaX;
-    mScanAreaY = scanAreaY;
-    mScanAreaWidth = scanAreaWidth;
-    mScanAreaHeight = scanAreaHeight;
-    mCameraViewWidth = cameraViewWidth;
-    mCameraViewHeight = cameraViewHeight;
-    mRatio = ratio;
-  }
-
-  @Override
-  protected Result doInBackground(Void... ignored) {
-    if (isCancelled() || mDelegate == null) {
-      return null;
-    }
-
-    /**
-     * mCameraViewWidth and mCameraViewHeight are obtained from portait orientation
-     * mWidth and mHeight are measured with landscape orientation with Home button to the right
-     * adjustedCamViewWidth is the adjusted width from the Aspect ratio setting
-     */
-    int adjustedCamViewWidth = (int) (mCameraViewHeight / mRatio);
-    float adjustedScanY = (((adjustedCamViewWidth - mCameraViewWidth) / 2) + (mScanAreaY * mCameraViewWidth)) / adjustedCamViewWidth;
-    
-    int left = (int) (mScanAreaX * mWidth);
-    int top = (int) (adjustedScanY * mHeight);
-    int scanWidth = (int) (mScanAreaWidth * mWidth);
-    int scanHeight = (int) (((mScanAreaHeight * mCameraViewWidth) / adjustedCamViewWidth) * mHeight);
-
-    try {
-      try {
-        BinaryBitmap bitmap = generateBitmapFromImageData(
-                mImageData,
-                mWidth,
-                mHeight,
-                false,
-                left,
-                top,
-                scanWidth,
-                scanHeight
-        );
-        return mMultiFormatReader.decodeWithState(bitmap);
-      } catch (NotFoundException e) {
-      }
-
-      try {
-        BinaryBitmap bitmap = generateBitmapFromImageData(
-                rotateImage(mImageData,mWidth, mHeight),
-                mHeight,
-                mWidth,
-                false,
-                mHeight - scanHeight - top,
-                left,
-                scanHeight,
-                scanWidth
-        );
-        return mMultiFormatReader.decodeWithState(bitmap);
-      } catch (NotFoundException e) {
-      }
-
-      try {
-        BinaryBitmap invertedBitmap = generateBitmapFromImageData(
-                mImageData,
-                mWidth,
-                mHeight,
-                true,
-                mWidth - scanWidth - left,
-                mHeight - scanHeight - top,
-                scanWidth,
-                scanHeight
-        );
-        return mMultiFormatReader.decodeWithState(invertedBitmap);
-      } catch (NotFoundException e) {
-      }
-
-      try {
-        BinaryBitmap invertedRotatedBitmap = generateBitmapFromImageData(
-                rotateImage(mImageData,mWidth, mHeight),
-                mHeight,
-                mWidth,
-                true,
-                top,
-                mWidth - scanWidth - left,
-                scanHeight,
-                scanWidth
-        );
-        return mMultiFormatReader.decodeWithState(invertedRotatedBitmap);
-      } catch (NotFoundException e) {
-      }
-    } catch (Throwable t) {
-      t.printStackTrace();
-    }
-
-    // no barcode found
-    return null;
-  }
-
-  private byte[] rotateImage(byte[]imageData,int width, int height) {
-    byte[] rotated = new byte[imageData.length];
-    for (int y = 0; y < height; y++) {
-      for (int x = 0; x < width; x++) {
-        rotated[x * height + height - y - 1] = imageData[x + y * width];
-      }
-    }
-    return rotated;
-  }
-
-  @Override
-  protected void onPostExecute(Result result) {
-    super.onPostExecute(result);
-    if (result != null) {
-      mDelegate.onBarCodeRead(result, mWidth, mHeight, mImageData);
-    }
-    mDelegate.onBarCodeScanningTaskCompleted();
-  }
-
-  private BinaryBitmap generateBitmapFromImageData(byte[] imageData, int width, int height, boolean inverse, int left, int top, int sWidth, int sHeight) {
-    PlanarYUVLuminanceSource source;
-    if (mLimitScanArea) {
-      source = new PlanarYUVLuminanceSource(
-        imageData, // byte[] yuvData
-        width, // int dataWidth
-        height, // int dataHeight
-        left, // int left
-        top, // int top
-        sWidth, // int width
-        sHeight, // int height
-        false // boolean reverseHorizontal
-      );
-    } else {
-      source = new PlanarYUVLuminanceSource(
-        imageData, // byte[] yuvData
-        width, // int dataWidth
-        height, // int dataHeight
-        0, // int left
-        0, // int top
-        width, // int width
-        height, // int height
-        false // boolean reverseHorizontal
-      );
-    }
-    if (inverse) {
-      return new BinaryBitmap(new HybridBinarizer(source.invert()));
-    } else {
-      return new BinaryBitmap(new HybridBinarizer(source));
-    }
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/BarCodeScannerAsyncTaskDelegate.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/BarCodeScannerAsyncTaskDelegate.java
deleted file mode 100644
index 7c75bae..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/BarCodeScannerAsyncTaskDelegate.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.reactnative.camera.tasks;
-
-import com.google.zxing.Result;
-
-public interface BarCodeScannerAsyncTaskDelegate {
-  void onBarCodeRead(Result barCode, int width, int height, byte[] imageData);
-  void onBarCodeScanningTaskCompleted();
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/BarcodeDetectorAsyncTaskDelegate.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/BarcodeDetectorAsyncTaskDelegate.java
deleted file mode 100644
index cf83ef3..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/BarcodeDetectorAsyncTaskDelegate.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package org.reactnative.camera.tasks;
-
-import com.facebook.react.bridge.WritableArray;
-import org.reactnative.barcodedetector.RNBarcodeDetector;
-
-public interface BarcodeDetectorAsyncTaskDelegate {
-
-    void onBarcodesDetected(WritableArray barcodes, int width, int height, byte[] imageData);
-
-    void onBarcodeDetectionError(RNBarcodeDetector barcodeDetector);
-
-    void onBarcodeDetectingTaskCompleted();
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/FaceDetectorAsyncTaskDelegate.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/FaceDetectorAsyncTaskDelegate.java
deleted file mode 100644
index 8cf97a6..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/FaceDetectorAsyncTaskDelegate.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package org.reactnative.camera.tasks;
-
-import org.reactnative.facedetector.RNFaceDetector;
-
-import com.facebook.react.bridge.WritableArray;
-
-public interface FaceDetectorAsyncTaskDelegate {
-  void onFacesDetected(WritableArray faces);
-  void onFaceDetectionError(RNFaceDetector faceDetector);
-  void onFaceDetectingTaskCompleted();
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/PictureSavedDelegate.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/PictureSavedDelegate.java
deleted file mode 100644
index 47a98bd..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/PictureSavedDelegate.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package org.reactnative.camera.tasks;
-
-import com.facebook.react.bridge.WritableMap;
-
-public interface PictureSavedDelegate {
-    void onPictureSaved(WritableMap response);
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/ResolveTakenPictureAsyncTask.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/ResolveTakenPictureAsyncTask.java
deleted file mode 100644
index 757d8d7..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/ResolveTakenPictureAsyncTask.java
+++ /dev/null
@@ -1,376 +0,0 @@
-package org.reactnative.camera.tasks;
-
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.Matrix;
-import android.net.Uri;
-import android.os.AsyncTask;
-import androidx.exifinterface.media.ExifInterface;
-import android.util.Base64;
-
-import org.reactnative.camera.RNCameraViewHelper;
-import org.reactnative.camera.utils.RNFileUtils;
-
-import com.facebook.react.bridge.Arguments;
-import com.facebook.react.bridge.Promise;
-import com.facebook.react.bridge.ReadableMap;
-import com.facebook.react.bridge.WritableMap;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-
-public class ResolveTakenPictureAsyncTask extends AsyncTask<Void, Void, WritableMap> {
-    private static final String ERROR_TAG = "E_TAKING_PICTURE_FAILED";
-    private Promise mPromise;
-    private Bitmap mBitmap;
-    private byte[] mImageData;
-    private ReadableMap mOptions;
-    private File mCacheDirectory;
-    private int mDeviceOrientation;
-    private int mSoftwareRotation;
-    private PictureSavedDelegate mPictureSavedDelegate;
-
-    public ResolveTakenPictureAsyncTask(byte[] imageData, Promise promise, ReadableMap options, File cacheDirectory, int deviceOrientation, int softwareRotation, PictureSavedDelegate delegate) {
-        mPromise = promise;
-        mOptions = options;
-        mImageData = imageData;
-        mCacheDirectory = cacheDirectory;
-        mDeviceOrientation = deviceOrientation;
-        mSoftwareRotation = softwareRotation;
-        mPictureSavedDelegate = delegate;
-    }
-
-    private int getQuality() {
-        return (int) (mOptions.getDouble("quality") * 100);
-    }
-
-    // loads bitmap only if necessary
-    private void loadBitmap() throws IOException {
-        if(mBitmap == null){
-            mBitmap = BitmapFactory.decodeByteArray(mImageData, 0, mImageData.length);
-        }
-        if(mBitmap == null){
-            throw new IOException("Failed to decode Image Bitmap");
-        }
-    }
-
-    @Override
-    protected WritableMap doInBackground(Void... voids) {
-        WritableMap response = Arguments.createMap();
-        ByteArrayInputStream inputStream = null;
-        ExifInterface exifInterface = null;
-        WritableMap exifData = null;
-        ReadableMap exifExtraData = null;
-
-        boolean exifOrientationFixed = false;
-
-        response.putInt("deviceOrientation", mDeviceOrientation);
-        response.putInt("pictureOrientation", mOptions.hasKey("orientation") ? mOptions.getInt("orientation") : mDeviceOrientation);
-
-
-        try{
-            // this replaces the skipProcessing flag, we will process only if needed, and in
-            // an orderly manner, so that skipProcessing is the default behaviour if no options are given
-            // and this behaves more like the iOS version.
-            // We will load all data lazily only when needed.
-
-            // this should not incur in any overhead if not read/used
-            inputStream = new ByteArrayInputStream(mImageData);
-
-            if (mSoftwareRotation != 0) {
-                loadBitmap();
-                mBitmap = rotateBitmap(mBitmap, mSoftwareRotation);
-            }
-
-            // Rotate the bitmap to the proper orientation if requested
-            if(mOptions.hasKey("fixOrientation") && mOptions.getBoolean("fixOrientation")){
-                exifInterface = new ExifInterface(inputStream);
-
-                // Get orientation of the image from mImageData via inputStream
-                int orientation = exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_UNDEFINED);
-
-                if(orientation != ExifInterface.ORIENTATION_UNDEFINED && getImageRotation(orientation) != 0) {
-                    loadBitmap();
-                    int angle = getImageRotation(orientation);
-                    mBitmap = rotateBitmap(mBitmap, angle);
-                    exifOrientationFixed = true;
-                }
-            }
-
-            if (mOptions.hasKey("width")) {
-                loadBitmap();
-                mBitmap = resizeBitmap(mBitmap, mOptions.getInt("width"));
-            }
-
-            if (mOptions.hasKey("mirrorImage") && mOptions.getBoolean("mirrorImage")) {
-                loadBitmap();
-                mBitmap = flipHorizontally(mBitmap);
-            }
-
-
-            // EXIF code - we will adjust exif info later if we manipulated the bitmap
-            boolean writeExifToResponse = mOptions.hasKey("exif") && mOptions.getBoolean("exif");
-
-            // default to true if not provided so it is consistent with iOS and with what happens if no
-            // processing is done and the image is saved as is.
-            boolean writeExifToFile = true;
-
-            if (mOptions.hasKey("writeExif")) {
-                switch (mOptions.getType("writeExif")) {
-                    case Boolean:
-                        writeExifToFile = mOptions.getBoolean("writeExif");
-                        break;
-                    case Map:
-                        exifExtraData = mOptions.getMap("writeExif");
-                        writeExifToFile = true;
-                        break;
-                }
-            }
-
-            // Read Exif data if needed
-            if (writeExifToResponse || writeExifToFile) {
-
-                // if we manipulated the image, or need to add extra data, or need to add it to the response,
-                // then we need to load the actual exif data.
-                // Otherwise we can just use w/e exif data we have right now in our byte array
-                if(mBitmap != null || exifExtraData != null || writeExifToResponse){
-                    if(exifInterface == null){
-                        exifInterface = new ExifInterface(inputStream);
-                    }
-                    exifData = RNCameraViewHelper.getExifData(exifInterface);
-
-                    if(exifExtraData != null){
-                        exifData.merge(exifExtraData);
-                    }
-                }
-
-                // if we did anything to the bitmap, adjust exif
-                if(mBitmap != null){
-                    exifData.putInt("width", mBitmap.getWidth());
-                    exifData.putInt("height", mBitmap.getHeight());
-
-                    if(exifOrientationFixed){
-                        exifData.putInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
-                    }
-                }
-
-                // Write Exif data to the response if requested
-                if (writeExifToResponse) {
-                    final WritableMap exifDataCopy = Arguments.createMap();
-                    exifDataCopy.merge(exifData);
-                    response.putMap("exif", exifDataCopy);
-                }
-            }
-
-
-
-            // final processing
-            // Based on whether or not we loaded the full bitmap into memory, final processing differs
-            if(mBitmap == null){
-                // set response dimensions. If we haven't read our bitmap, get it efficiently
-                // without loading the actual bitmap into memory
-                BitmapFactory.Options options = new BitmapFactory.Options();
-                options.inJustDecodeBounds = true;
-                BitmapFactory.decodeByteArray(mImageData, 0, mImageData.length, options);
-                if(options != null){
-                    response.putInt("width", options.outWidth);
-                    response.putInt("height", options.outHeight);
-                }
-
-
-                // save to file if requested
-                if (!mOptions.hasKey("doNotSave") || !mOptions.getBoolean("doNotSave")) {
-
-                    // Prepare file output
-                    File imageFile = new File(getImagePath());
-
-                    imageFile.createNewFile();
-
-                    FileOutputStream fOut = new FileOutputStream(imageFile);
-
-                    // Save byte array (it is already a JPEG)
-                    fOut.write(mImageData);
-                    fOut.flush();
-                    fOut.close();
-
-                    // update exif data if needed.
-                    // Since we didn't modify the image, we only update if we have extra exif info
-                    if (writeExifToFile && exifExtraData != null) {
-                        ExifInterface fileExifInterface = new ExifInterface(imageFile.getAbsolutePath());
-                        RNCameraViewHelper.setExifData(fileExifInterface, exifExtraData);
-                        fileExifInterface.saveAttributes();
-                    }
-                    else if (!writeExifToFile){
-                        // if we were requested to NOT store exif, we actually need to
-                        // clear the exif tags
-                        ExifInterface fileExifInterface = new ExifInterface(imageFile.getAbsolutePath());
-                        RNCameraViewHelper.clearExifData(fileExifInterface);
-                        fileExifInterface.saveAttributes();
-                    }
-                    // else: exif is unmodified, no need to update anything
-
-                    // Return file system URI
-                    String fileUri = Uri.fromFile(imageFile).toString();
-                    response.putString("uri", fileUri);
-                }
-
-                if (mOptions.hasKey("base64") && mOptions.getBoolean("base64")) {
-                    response.putString("base64", Base64.encodeToString(mImageData, Base64.NO_WRAP));
-                }
-
-            }
-            else{
-                // get response dimensions right from the bitmap if we have it
-                response.putInt("width", mBitmap.getWidth());
-                response.putInt("height", mBitmap.getHeight());
-
-                // Cache compressed image in imageStream
-                ByteArrayOutputStream imageStream = new ByteArrayOutputStream();
-                if (!mBitmap.compress(Bitmap.CompressFormat.JPEG, getQuality(), imageStream)) {
-                    mPromise.reject(ERROR_TAG, "Could not compress image to JPEG");
-                    return null;
-                }
-
-                // Write compressed image to file in cache directory unless otherwise specified
-                if (!mOptions.hasKey("doNotSave") || !mOptions.getBoolean("doNotSave")) {
-                    String filePath = writeStreamToFile(imageStream);
-
-                    // since we lost any exif data on bitmap creation, we only need
-                    // to add it if requested
-                    if (writeExifToFile && exifData != null) {
-                        ExifInterface fileExifInterface = new ExifInterface(filePath);
-                        RNCameraViewHelper.setExifData(fileExifInterface, exifData);
-                        fileExifInterface.saveAttributes();
-                    }
-                    File imageFile = new File(filePath);
-                    String fileUri = Uri.fromFile(imageFile).toString();
-                    response.putString("uri", fileUri);
-                }
-
-                // Write base64-encoded image to the response if requested
-                if (mOptions.hasKey("base64") && mOptions.getBoolean("base64")) {
-                    response.putString("base64", Base64.encodeToString(imageStream.toByteArray(), Base64.NO_WRAP));
-                }
-
-            }
-
-            return response;
-
-        }
-        catch (Resources.NotFoundException e) {
-            mPromise.reject(ERROR_TAG, "Documents directory of the app could not be found.", e);
-            e.printStackTrace();
-        }
-        catch (IOException e) {
-            mPromise.reject(ERROR_TAG, "An unknown I/O exception has occurred.", e);
-            e.printStackTrace();
-        }
-        finally {
-            try {
-                if (inputStream != null) {
-                    inputStream.close();
-                }
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-
-        return null;
-    }
-
-    private Bitmap rotateBitmap(Bitmap source, int angle) {
-        Matrix matrix = new Matrix();
-        matrix.postRotate(angle);
-        return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true);
-    }
-
-    private Bitmap resizeBitmap(Bitmap bm, int newWidth) {
-        int width = bm.getWidth();
-        int height = bm.getHeight();
-        float scaleRatio = (float) newWidth / (float) width;
-
-        return Bitmap.createScaledBitmap(bm, newWidth, (int) (height * scaleRatio), true);
-    }
-
-    private Bitmap flipHorizontally(Bitmap source) {
-        Matrix matrix = new Matrix();
-        matrix.preScale(-1.0f, 1.0f);
-        return Bitmap.createBitmap(source, 0, 0, source.getWidth(), source.getHeight(), matrix, true);
-    }
-
-    // Get rotation degrees from Exif orientation enum
-
-    private int getImageRotation(int orientation) {
-        int rotationDegrees = 0;
-        switch (orientation) {
-        case ExifInterface.ORIENTATION_ROTATE_90:
-            rotationDegrees = 90;
-            break;
-        case ExifInterface.ORIENTATION_ROTATE_180:
-            rotationDegrees = 180;
-            break;
-        case ExifInterface.ORIENTATION_ROTATE_270:
-            rotationDegrees = 270;
-            break;
-        }
-        return rotationDegrees;
-    }
-
-    private String getImagePath() throws IOException{
-        if(mOptions.hasKey("path")){
-            return mOptions.getString("path");
-        }
-        return RNFileUtils.getOutputFilePath(mCacheDirectory, ".jpg");
-    }
-
-    private String writeStreamToFile(ByteArrayOutputStream imageDataStream) throws IOException {
-        String outputPath = null;
-        IOException exception = null;
-        FileOutputStream fileOutputStream = null;
-
-        try {
-            outputPath = getImagePath();
-            fileOutputStream = new FileOutputStream(outputPath);
-            imageDataStream.writeTo(fileOutputStream);
-        } catch (IOException e) {
-            e.printStackTrace();
-            exception = e;
-        } finally {
-            try {
-                if (fileOutputStream != null) {
-                    fileOutputStream.close();
-                }
-            } catch (IOException e) {
-                e.printStackTrace();
-            }
-        }
-
-        if (exception != null) {
-            throw exception;
-        }
-
-        return outputPath;
-    }
-
-    @Override
-    protected void onPostExecute(WritableMap response) {
-        super.onPostExecute(response);
-
-        // If the response is not null everything went well and we can resolve the promise.
-        if (response != null) {
-            if (mOptions.hasKey("fastMode") && mOptions.getBoolean("fastMode")) {
-                WritableMap wrapper = Arguments.createMap();
-                wrapper.putInt("id", mOptions.getInt("id"));
-                wrapper.putMap("data", response);
-                mPictureSavedDelegate.onPictureSaved(wrapper);
-            } else {
-                mPromise.resolve(response);
-            }
-        }
-    }
-
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/TextRecognizerAsyncTaskDelegate.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/TextRecognizerAsyncTaskDelegate.java
deleted file mode 100644
index 1cf44af..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/tasks/TextRecognizerAsyncTaskDelegate.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package org.reactnative.camera.tasks;
-
-import com.facebook.react.bridge.WritableArray;
-
-public interface TextRecognizerAsyncTaskDelegate {
-  void onTextRecognized(WritableArray serializedData);
-  void onTextRecognizerTaskCompleted();
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/utils/ImageDimensions.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/utils/ImageDimensions.java
deleted file mode 100644
index 4e13205..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/utils/ImageDimensions.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package org.reactnative.camera.utils;
-
-public class ImageDimensions {
-  private int mWidth;
-  private int mHeight;
-  private int mFacing;
-  private int mRotation;
-
-  public ImageDimensions(int width, int height) {
-    this(width, height, 0);
-  }
-
-  public ImageDimensions(int width, int height, int rotation) {
-    this(width, height, rotation, -1);
-  }
-
-  public ImageDimensions(int width, int height, int rotation, int facing) {
-    mWidth = width;
-    mHeight = height;
-    mFacing = facing;
-    mRotation = rotation;
-  }
-
-  public boolean isLandscape() {
-    return mRotation % 180 == 90;
-  }
-
-  public int getWidth() {
-    if (isLandscape()) {
-      return mHeight;
-    }
-
-    return mWidth;
-  }
-
-  public int getHeight() {
-    if (isLandscape()) {
-      return mWidth;
-    }
-
-    return mHeight;
-  }
-
-  public int getRotation() {
-    return mRotation;
-  }
-
-  public int getFacing() {
-    return mFacing;
-  }
-
-  @Override
-  public boolean equals(Object obj) {
-    if (obj instanceof ImageDimensions) {
-      ImageDimensions otherDimensions = (ImageDimensions) obj;
-      return (otherDimensions.getWidth() == getWidth() &&
-              otherDimensions.getHeight() == getHeight() &&
-              otherDimensions.getFacing() == getFacing() &&
-              otherDimensions.getRotation() == getRotation());
-    } else {
-      return super.equals(obj);
-    }
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/utils/ObjectUtils.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/utils/ObjectUtils.java
deleted file mode 100644
index 15ce89c..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/utils/ObjectUtils.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.reactnative.camera.utils;
-
-
-public class ObjectUtils {
-
-    /*
-    * Replacement for Objects.equals that is only available after Android API 19
-    */
-    public static boolean equals(Object o1, Object o2) {
-        if (o1 == null && o2 == null) return true;
-        if (o1 == null) return false;
-        return o1.equals(o2);
-    }
-
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/utils/RNFileUtils.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/utils/RNFileUtils.java
deleted file mode 100644
index f0dd871..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/utils/RNFileUtils.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package org.reactnative.camera.utils;
-
-import android.content.Context;
-import android.net.Uri;
-
-
-import java.io.File;
-import java.io.IOException;
-import java.util.UUID;
-
-/**
- * Created by jgfidelis on 23/01/18.
- */
-
-public class RNFileUtils {
-
-    public static File ensureDirExists(File dir) throws IOException {
-        if (!(dir.isDirectory() || dir.mkdirs())) {
-            throw new IOException("Couldn't create directory '" + dir + "'");
-        }
-        return dir;
-    }
-
-    public static String getOutputFilePath(File directory, String extension) throws IOException {
-        ensureDirExists(directory);
-        String filename = UUID.randomUUID().toString();
-        return directory + File.separator + filename + extension;
-    }
-
-    public static Uri uriFromFile(File file) {
-        return Uri.fromFile(file);
-    }
-
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/utils/ScopedContext.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/utils/ScopedContext.java
deleted file mode 100644
index 0daec43..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/camera/utils/ScopedContext.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package org.reactnative.camera.utils;
-
-import android.content.Context;
-
-import java.io.File;
-
-/**
- * Created by jgfidelis on 23/01/18.
- */
-
-public class ScopedContext {
-
-    private File cacheDirectory = null;
-
-    public ScopedContext(Context context) {
-        createCacheDirectory(context);
-    }
-
-    public void createCacheDirectory(Context context) {
-        cacheDirectory = new File(context.getCacheDir() + "/Camera/");
-    }
-
-    public File getCacheDirectory() {
-        return cacheDirectory;
-    }
-
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/frame/RNFrame.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/frame/RNFrame.java
deleted file mode 100644
index 90a797c..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/frame/RNFrame.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.reactnative.frame;
-
-import org.reactnative.camera.utils.ImageDimensions;
-import com.google.mlkit.vision.common.InputImage;
-
-/**
- * Wrapper around Frame allowing us to track Frame dimensions.
- * Tracking dimensions is used in RNFaceDetector and RNBarcodeDetector to provide painless FaceDetector/BarcodeDetector recreation
- * when image dimensions change.
- */
-
-public class RNFrame {
-  private InputImage mFrame;
-  private ImageDimensions mDimensions;
-
-  public RNFrame(InputImage frame, ImageDimensions dimensions) {
-    mFrame = frame;
-    mDimensions = dimensions;
-  }
-
-  public InputImage getFrame() {
-    return mFrame;
-  }
-
-  public ImageDimensions getDimensions() {
-    return mDimensions;
-  }
-}
diff --git a/node_modules/react-native-camera/android/src/main/java/org/reactnative/frame/RNFrameFactory.java b/node_modules/react-native-camera/android/src/main/java/org/reactnative/frame/RNFrameFactory.java
deleted file mode 100644
index c452a84..0000000
--- a/node_modules/react-native-camera/android/src/main/java/org/reactnative/frame/RNFrameFactory.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package org.reactnative.frame;
-
-import android.graphics.Bitmap;
-
-import org.reactnative.camera.utils.ImageDimensions;
-import com.google.mlkit.vision.common.InputImage;
-
-import java.nio.ByteBuffer;
-
-public class RNFrameFactory {
-  public static RNFrame buildFrame(byte[] bitmapData, int width, int height, int rotation) {
-    ByteBuffer byteBuffer = ByteBuffer.wrap(bitmapData);
-    ImageDimensions dimensions = new ImageDimensions(width, height, rotation);
-    InputImage image = InputImage.fromByteBuffer(byteBuffer, width, height, rotation, InputImage.IMAGE_FORMAT_NV21);
-    return new RNFrame(image, dimensions);
-  }
-
-  public static RNFrame buildFrame(Bitmap bitmap) {
-    ImageDimensions dimensions = new ImageDimensions(bitmap.getWidth(), bitmap.getHeight());
-    InputImage image = InputImage.fromBitmap(bitmap, 0);
-    return new RNFrame(image, dimensions);
-  }
-}
